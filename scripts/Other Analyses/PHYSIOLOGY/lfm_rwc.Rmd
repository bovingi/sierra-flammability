---
title: "RWC x LFM"
author: "Indra Boving"
date: "10/24/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
library(janitor)
library(tidyverse)
library(plotly)
library(DT)
library(broom)
library(lubridate)
library(udpipe)
```

### Species data from literature:

```{r}
p50s <- c(-2.65, -3.74, -7.98, -7.75, -8.08, NA, NA, NA, NA, -4.41)
spp.p50 <- c("PIPO", "ABCO", "ADFA", "CADE", "CEME", "QUKE", "CECO", "PIJE", "ARPA", "ARGL")

p50_reference <- c()

tlp <- c(-2.91, NA, -3.4, -3.14, -2.24, -2.8, -2.6, NA, NA, NA)
spp.tlp <- c("PIPO", "ABCO", "ADFA", "ADFA", "CEME", "CEME", "ABGR", NA, NA, NA)

tlp_reference <-c("Jackson & Spomer, 1979", NA, "Pivavoroff, 2019", "Ramirez dissertation", "Ramirez dissertation", "Fletcher et al. 2018", "Jackson & Spomer, 1979", NA, NA, NA)

lit_values <- data.frame(spp.p50, p50s, spp.tlp, tlp, tlp_reference)
datatable(lit_values)
```

### Pressure Volume Curves:

# Read in data and clean names

```{r}
data <- read_csv(here("data", "allcurves.csv")) %>% 
  clean_names() %>% 
  mutate(lfm = (((fresh_weight - dry_weight)/dry_weight)* 100)) %>%
  mutate(neg_mpa = -1/water_potential) %>% 
  mutate(sample = as.character(sample)) %>% 
  mutate(date = as.Date(date, format = '%m.%d.%Y')) %>% 
  mutate(year = year(date)) %>% 
  mutate(month = month(date))
```

Visualize to make sure everything makes sense:

```{r, warning = F}
data %>% 
ggplot(aes(y = neg_mpa, x = rwd, color = spp)) + 
  geom_jitter(alpha = .5, size = 1) +
  labs(title = "Pressure Volume Curves",
         y = "-1/Mpa", 
       x = "Relative Water Deficit (%)") +
  theme_bw()
```

# Visualize LFM and Mpa ("Pressure Moisture Curves"):

```{r, warning = F}
data %>% 
ggplot(aes(y = neg_mpa, x = lfm, color = spp)) + 
  geom_jitter(alpha = .5, size = 1) +
  labs(title = "Pressure Moisture Curves", 
       y = "-1/Mpa", 
       x = "Live Fuel Moisture (%)") +
  theme_bw()
```

# Non-transformed Mpa:

```{r}
all <- data %>% 
ggplot(aes(y = water_potential, x = lfm, color = spp)) + 
  geom_jitter(alpha = .5, size = 1) +
  labs(title = "Pressure Volume Curves", 
       y = "Mpa", 
       x = "Live Fuel Moisture (%)") +
  theme_bw()
all
ggplotly(all, tooltip = c("spp"))
```

Look at just one species: Abies concolor

Abies concolor: gymnosperm with P50 of -3.74 (Choat et. al)

In fall only:

```{r}
pv.abco.all <- data %>% 
  filter(spp == "ABCO")

ggplot(pv.abco.all) +
  geom_point(aes(y = rwd, x = neg_mpa)) +
  theme_bw()

pv.abco.fall.summary <- data %>%
  group_by(date) %>% 
  filter(spp == "ABCO" & timing == "fall" ) %>% 
  summarise(n=n(), mean=mean(tlp),sd=sd(tlp))
```

```{r}
ggplot(pv.abco.fall.summary) +
    geom_bar(aes(y = mean, x = date), position="dodge", stat="identity") +
    geom_errorbar(aes(x=date, ymin=mean-sd, ymax=mean+sd), width=0.4, colour="black", alpha=0.9) +
   labs(title = "ABCO TLP, fall dates") +
   theme_bw()
```

In fall and spring: - fall both dates combined:

```{r}
pv.abco.summary <- data %>%
  group_by(timing) %>% 
  filter(spp == "ABCO") %>% 
  summarise(n=n(), mean=mean(tlp),sd=sd(tlp))

 ggplot(pv.abco.summary) +
    geom_bar(aes(y = mean, x = timing), position="dodge", stat="identity") +
    geom_errorbar(aes(x=timing, ymin=mean-sd, ymax=mean+sd), width=0.4, colour="black", alpha=0.9) +
   labs(title = "ABCO TLP, all dates", 
        y = "TLP (-Mpa)", 
        x = "timing") +
   theme_bw()
```

See if difference:

-   Split df into groups, then pull sample vectors

```{r}
fall.abco <- pv.abco.all %>% 
  filter(timing == "fall") %>% 
  pull(tlp)

spring.abco <- pv.abco.all %>% 
  filter(timing == "spring") %>% 
  pull(tlp)

abco_tlp_t <- t.test(spring.abco, fall.abco)
abco_tlp_t
```

# Working with all samples again, what is the relationship between RWC and TLP?

```{r}
ggplot(data = data, aes(y = swc, x = rwc_at_tlp, color = spp)) +
  geom_point(alpha = .8, size = 1) +
  labs(title = "TLP and RWC at TLP",
       y = "TLP (-Mpa)", 
       x = "SWC (grams water/gram dry ")  +
  geom_smooth(method='lm') +
  theme_bw()
```

```{r}
ggplot(data = data, aes(y = tlp, x = lfm_at_tlp, color = spp)) +
  geom_point(alpha = .8, size = 1) +
  labs(title = "TLP and LFM at TLP",
       y = "TLP (-Mpa)", 
       x = "LFM (%)") +
  geom_smooth(method='lm') +
  theme_bw()
```

```{r}
ggplot(data = data, aes(y = tlp, x = lfm_at_tlp)) +
  geom_point(alpha = .8, size = 1) +
  labs(title = "TLP and LFM at TLP",
       y = "TLP (-Mpa)", 
       x = "LFM (%)") +
  geom_smooth(method='lm') +
  theme_bw()
```

Get tlps into dataframe so we can look at them more closely:

```{r}
tlp <- data %>% 
  group_by(spp, date) %>% 
  summarise(meantlp = mean(tlp), sd = sd(tlp))
tlp
```

```{r}
pv.summary.date <- data %>%
  mutate(month_char = as.character(month)) %>% 
  group_by(month_char, spp) %>% 
  summarise(n=n(), mean=mean(tlp),sd=sd(tlp))

 ggplot(pv.summary.date, aes(y = mean, x = spp, fill = month_char)) +
    geom_bar(stat = "identity", position="dodge") +
    geom_errorbar(aes(x = spp, ymin=mean-sd, ymax=mean+sd), position=position_dodge(0.9), width=.5, color = "black", size = .5) +
   labs(title = "ABCO TLP with sd", y = "TLP", x = "Species") +
   theme_bw()
```

Look at all TLPs based on timing:

```{r}
pv.summary.timing <- data %>%
  group_by(timing, spp) %>% 
  summarise(n=n(), mean=mean(tlp),sd=sd(tlp))

pv.summary.spp <- data %>%
  group_by(spp) %>% 
  summarise(n=n(), mean=mean(tlp),sd=sd(tlp))

 ggplot(pv.summary.timing, aes(y = mean, x = spp, fill = timing)) +
    geom_bar(stat = "identity", position="dodge") +
    geom_errorbar(aes(x = spp, ymin=mean-sd, ymax=mean+sd), position=position_dodge(0.9), width=.5, color = "black", size = .5) +
   labs(title = "ABCO TLP with sd", y = "TLP", x = "Species") +
   theme_bw() +
   scale_fill_manual(values = c("goldenrod", "lightgreen"))
```

# Try to predict Mpa from LFM with just one species:

### Abies concolor

1.  Get datasets in order:

-   select for just the species and date we are interested in
-   pull the TLP as a value
-   use the value we created to select just the points above the TLP and make one dataset, and also another dataset with just the points below the TLP

```{r message=FALSE, warnings=F}
pv.abco.fall <- data %>%
  filter(spp == "ABCO" & timing == "fall" ) %>% 
  filter(sample != 3)

abco.tlp <- pv.abco.fall %>% 
  summarise(mean(tlp)) %>% pull()
abco.tlp
```

```{r message=FALSE, warnings=F}
pv.abco.fall %>% 
  ggplot(aes(y = water_potential, x = lfm)) +
  geom_point() +
  geom_hline(yintercept = abco.tlp,
             colour = "cyan") +
  theme_bw()

pv.abco.fall %>% 
  ggplot(aes(y = water_potential, x = lfm, color = date)) +
  geom_point() +
  geom_hline(yintercept = abco.tlp,
             colour = "cyan") +
  labs(title = "ABCO Pressure Volume Curves, LFM x Mpa")
  theme_bw()
```

Bar chart of TLP and sd:

```{r}
pv.abco.fall.summary <- data %>%
  group_by(date) %>% 
  filter(spp == "ABCO" & timing == "fall" ) %>% 
  summarise(n=n(), mean=mean(tlp),sd=sd(tlp))

 ggplot(pv.abco.fall.summary) +
    geom_bar(aes(y = mean, x = date), position="dodge", stat="identity") +
    geom_errorbar(aes(x=date, ymin=mean-sd, ymax=mean+sd), width=0.4, colour="orange", alpha=0.9, size=1.3) +
   labs(title = "ABCO TLP with sd") +
   theme_bw()
```

```{r}
abco.above.tlp <- pv.abco.fall %>% 
  filter(water_potential > tlp)

abco.below.tlp <- pv.abco.fall %>% 
  filter(water_potential < tlp)
```

2.  For points below the TLP, there should be a linear relationship between -1/Mpa and LFM

```{r}
abco.below.tlp %>% 
ggplot(aes(y = -1/water_potential, x = lfm, color = sample, shape = as.factor(month))) +
  geom_jitter(alpha = .6, size = 1) +
  geom_smooth(method = "lm", se = FALSE) +
  theme_bw()

fit.below <-lm(-1/water_potential~lfm, abco.below.tlp)
summary(fit.below)

mpa.predicted.r <- predict.lm(fit.below, newdata = data_frame(lfm = 180)) %>% as.numeric() #use this to extract lfm
mpa.predicted.r
```

3.  For points above the TLP, there should be a linear relationship between Mpa and lfm

```{r}
ggplot(data = abco.above.tlp, aes(y = water_potential, x = lfm, color = sample, shape = as.factor(date))) +
  geom_jitter(alpha = .6, size = 1) +
  geom_smooth(method = "lm", se = FALSE) +
  theme_bw()

fit.above <- lm(water_potential ~ lfm, abco.above.tlp)
summary(fit.above)

lfm.predicted.r.fit1 <- predict.lm(fit.above, newdata = data_frame(lfm = 150, swc = 1.3)) %>% as.numeric() #use this to extract lfm
lfm.predicted.r.fit1
```

Adding in SWC might help model?

```{r}
fit2 <- lm(water_potential ~ lfm + swc, abco.above.tlp)
summary(fit2)

lfm.predicted.r <- predict.lm(fit2, newdata = data_frame(lfm = 150, swc = 1.3)) %>% as.numeric() #use this to extract lfm
lfm.predicted.r
```

Cool! We have some linear models that should be able to predict LFM from Mpa. Now, to test it out...

# Section 2: Can we predict field- or flam-collected values using the models built from the PV curves?

## Subsection 2.1: 
- Read in data
- Calculate SWC so we can get RWC

These were constructed via simultaneous measurements on LFM and Mpa during flammability testing.

```{r warning=FALSE}
flam_curve_phys_czo <- read_csv(here("data", "czo.flam.curve.physiological.data.csv")) %>% 
  clean_names() %>% 
  mutate(location = "czo")

flam_curve_phys_seki <- read_csv(here("data", "seki.flam.curve.physiological.data.csv")) %>% 
  clean_names() %>% 
  mutate(location = "seki")

flam_curve_phys_local <- read_csv(here("data", "local.flam.curve.physiological.data.csv")) %>%
  clean_names() %>% 
  mutate(location = "local")

flam_curve_phys_all <- rbind(flam_curve_phys_czo, flam_curve_phys_local, flam_curve_phys_seki) %>% 
  mutate(lfm = lfm_n_as_imputed, water_potential = mpa) %>% 
  mutate(pos_mpa = -1*water_potential) %>% 
  mutate(month = case_when(
    year_month == "2020_September" ~ 9, 
    year_month == "2020_January" ~ 1, 
    year_month == "2020_October" ~ 10, 
    year_month == "2016_December" ~ 12,
    year_month == "2019_December" ~ 9, 
    year_month == "2028_January" ~ 1)) %>% 
  mutate(timing = case_when(
     year_month == "2020_September" ~ "fall", 
    year_month == "2020_January" ~ "spring", 
    year_month == "2020_October" ~ "fall", 
    year_month == "2016_December" ~ "fall",
    year_month == "2019_December" ~ "fall", 
    year_month == "2028_January" ~ "spring")) %>% 
  select(individual, year_month, month, timing, dry_wt, spp, model, rwc, lfm, max_mpa_sample, mpa, gww_gdw, gww_gdw_saturated, fresh_wt, site, sample, location, pos_mpa, water_potential)

#merge the tlps from the PV curve summary into the flam curve dataset: 

##note: TLPs are species means, NOT from specific sampling times (should only matter for ABCO)
flam_curve_phys_all <- merge(flam_curve_phys_all, pv.summary.spp, by = "spp", all = T) %>% 
  mutate(tlp = mean) %>% 
  select(-mean)
```

This is effectively what we're trying to do to get the saturated water content except we'll do it for each individual, not for each species. 
```{r}
ggplot(flam_curve_phys_all, aes(x = pos_mpa, y = gww_gdw, color = spp)) +
  geom_point(alpha = .3) +
  geom_smooth(method = "lm") +
  labs(title = "Intercept = saturated water content", 
       y = "water:dry matter", 
       x = "water potential (+Mpa)")
```

We need the extrapolated saturated water content so that we can determine the relative water content. We do that here by: 
1. Finding a lm for each indvidual that relates **water content:dry matter** with **water potential**.
2. Extracting the y-intercept. This is the extrapolated saturated water content. 
3. Add that value back into the dataset so it is useful. 

```{r, warning= FALSE}
#get the extrapolated saturated water content:
swc_all <- flam_curve_phys_all %>% 
  filter(mpa > tlp) %>% #for points above the tlp (estimated to be around ~2)
  group_by(individual) %>% 
  summarise(swc_sat = lm(formula = gww_gdw ~ pos_mpa)$coefficients[["(Intercept)"]]) 

# try.broom <- flam_curve_phys_all %>%
#   filter(mpa > -2) %>%
#   group_by(individual) %>%
#   do(broom::tidy(lm(gww_gdw ~ pos_mpa, .))) %>%
#   filter(term == "(Intercept)") %>%
#   select(individual, estimate)
# 
# merged <- merge(try.broom, swc_all, by = "individual", all = T)
# 
# merged %>% 
#   ggplot(aes(y = estimate, x = swc_sat)) +
#   geom_point()

#add that back to the master dataset:
flam_curve_phys_all <- merge(flam_curve_phys_all, swc_all, by="individual", all = T) %>%
  mutate(rwc_new = 100 * (gww_gdw/swc_sat))
```


```{r, warning= FALSE}
subset <- flam_curve_phys_all %>% 
  select(individual, dry_wt, lfm, mpa,pos_mpa, gww_gdw, tlp, swc_sat, rwc_new, spp) %>% 
  filter(rwc_new > 100)

unique(subset$individual)

ggplot(subset, aes(x = pos_mpa, y = gww_gdw)) +
  geom_point(alpha = .3) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Intercept = saturated water content", 
       y = "water:dry matter", 
       x = "water potential (+Mpa)") +
  facet_wrap(~spp)

subset %>% 
  ggplot(aes(y = mpa, x = rwc_new, color = spp)) +
  geom_point()

#Visualize: 
flam_curve_phys_all %>% 
ggplot(aes(y = swc_sat, x = individual, color = spp, color = individual)) +
  geom_col() +
  theme()

# ggplot(flam_curves_phys_all_swc, aes(y = gww_gdw, x = swc_sat, color = spp)) +
#   geom_point() +
#   labs(title = "saturated wet weight calculated two different ways", 
#        y = "based on greatest gww/gdw per individual", 
#        x = "based on linear regression extrapolation") +
#   theme_bw()
```

```{r}
flam_curve_phys_all %>%
  filter(individual == "2020_September_CEME_1.3") %>%
  ggplot(aes(x = pos_mpa, y = gww_gdw, color = individual)) +
  geom_point(alpha = .3) +
  geom_smooth(method = "lm")

# 
# flam_curve_phys_all %>% 
#   filter(spp == "ADFA") %>% 
#   ggplot(aes(x = pos_mpa, y = gww_gdw, color = individual)) +
#   geom_point(alpha = .3) +
#   geom_smooth(method = "lm")
# 
# flam_curve_phys_all %>% 
#   filter(spp == "ARPA") %>% 
#   ggplot(aes(x = pos_mpa, y = gww_gdw, color = individual)) +
#   geom_point(alpha = .3) +
#   geom_smooth(method = "lm", alpha = .1)
flam_curve_phys_all %>% 
  filter(rwc_new < 100) %>% 
ggplot(aes(y = -1/mpa, x = 100 - rwc_new, color = spp)) +
  geom_point(alpha = .3)

flam_curve_phys_all %>% 
  filter(rwc_new < 100) %>% 
ggplot(aes(y = -1/mpa, x = 100 - rwc_new, color = spp)) +
  geom_point(alpha = .3)
```

## Subsection 2.2
- Use `predict()` to see if we can use PV curve models to get values collected during flammability curve testing. 

```{r}
#Our models: 
fit.below
fit.above
```
We're just interested in ABCO, so just look there: 
```{r}
flam_curve_phys_abco_above <- flam_curve_phys_all %>% 
  filter(rwc_new < 100) %>% 
  filter(spp == "ABCO") %>% 
  filter(mpa > tlp)

flam_curve_phys_abco_below <- flam_curve_phys_all %>% 
  filter(rwc_new < 100) %>% 
  filter(spp == "ABCO") %>% 
  filter(mpa < tlp)
```

```{r}
predict.below <- predict(fit.below, newdata = flam_curve_phys_abco_below, se.fit = TRUE, interval = "confidence") #make prediction

# Bind to the data to make it actually useful:

predict.df.below <- data.frame(flam_curve_phys_abco_below, predict.below)

predict.df.below %>% 
  ggplot(aes(y = -1/water_potential, x = fit.fit)) +
  geom_point() +
  geom_abline(method = lm) +
  geom_abline(color = "red") +
  ylim(0, 1) +
  xlim(0, 1) +
  labs(title = "Actual vs. predicted water potential for points BELOW the TLP", 
       y = "Actual -1/Mpa", 
       x = "Predicted -1/Mpa")

predict.df.below %>% 
  ggplot(aes(y = water_potential, x = -1/fit.fit)) +
  geom_point() +
  geom_abline(method = lm) +
  geom_abline(color = "red") +
  ylim(0, -10) +
  xlim(0, -10) +
  labs(title = "Actual vs. predicted water potential for points BELOW the TLP", 
       y = "Actual Mpa", 
       x = "Predicted Mpa")
```

Then visualize it!

```{r graph, echo = FALSE, messages = "hide", warning = FALSE}
predict_graph_below <- ggplot(predict.df.below, aes(x = lfm, y = -1/fit.fit)) +
  geom_point(color = "cyan", alpha = 0.5) +
  geom_point(data = flam_curve_phys_abco_below, aes(x = lfm, y = mpa), alpha = 0.5) +
 # facet_wrap(~St) +
  labs(x = "Actual LFM", 
       y = "Water Potential", 
       title = "Predicted (cyan) vs. observed (black) LFM and Mpa") +
 # scale_x_continuous(limits = c(500,3500), breaks = seq(500, 3500, by = 1000)) +
 # scale_y_continuous(limits = c(0,1.5e6))
  theme_light() 
predict_graph_below
```
```{r}
predict.above <- predict(fit.above, newdata = flam_curve_phys_abco_above, se.fit = TRUE, interval = "confidence") #make prediction

# Bind to the data to make it actually useful:

predict.df.above <- data.frame(flam_curve_phys_abco_above, predict.above)

predict.df.above %>% 
  ggplot(aes(y = water_potential, x = fit.fit)) +
  geom_point() +
  geom_abline(method = lm) +
  geom_abline(color = "red") +
  ylim(0, -3) +
  xlim(0, -3) +
  labs(title = "Actual vs. predicted water potential for points above the TLP", 
       y = "Actual Mpa", 
       x = "Predicted Mpa")
```
```{r graph, echo = FALSE, messages = "hide", warning = FALSE}
predict_graph_above <- ggplot(predict.df.above, aes(x = lfm, y = fit.fit)) +
  geom_point(color = "cyan", alpha = 0.5) +
  geom_point(data = flam_curve_phys_abco_above, aes(x = lfm, y = mpa), alpha = 0.5) +
 # facet_wrap(~St) +
  labs(x = "Actual LFM", 
       y = "Water Potential", 
       title = "Predicted (cyan) vs. observed (black) LFM and Mpa") +
 # scale_x_continuous(limits = c(500,3500), breaks = seq(500, 3500, by = 1000)) +
 # scale_y_continuous(limits = c(0,1.5e6))
  theme_light() 
predict_graph_above
```
