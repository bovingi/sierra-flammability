---
title: 'Data Wrangling: Sierra Flam. Curves (SEKI)'
author: "Indra Boving"
date: "2/19/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# First, let's get our data how we want it
To load in necessary packages and dataset:
```{r}
library(simputation)
library(visdat)
library(ggplot2) 
library(gapminder)
library(data.table)
library(purrr) #for visualizing all variables in one big plot
library(naniar) #deal with NAs
library(dplyr)
library(tidyverse)
library(ggpubr)
filter = dplyr::filter #correct filter problem (gets confused with stats::filter)
library(purrr) #for visualizing all variables in one big plot
#install.packages("naniar")
library(psych) #for multi.hist
library(here)
here = here::here
```

```{r}
#NOTE: Make sure excel shows that flam metrics are Numeric, or else you'll have to convert in R
raw.data <- read_csv(here("raw-data/SEKI_flammability.csv"))
str(raw.data)
```

Now to make a bunch of NA values with values that don't make sense and/or are supposed to be NA, but R did not recognize them immediately as NA:

```{r}
#View NAs:
colSums(is.na(raw.data))

#For missing values/0s/negative values (neg due to missing in related cells):
data.with.na <- raw.data %>% 
  replace_with_na(replace = list(temp.max = c(0, 0.0))) %>% #for missing temp maxs, make NA
  replace_with_na(replace = list(ignition.temp = c(0, 0.0))) %>% #for missing temp at ignition, make NA 
  replace_with_na(replace = list(start.temp = c(0, 0.0))) %>% #for missing starting temp 
  replace_with_na(replace = list(sample.wt = c(0, 0.0))) %>% #for sample weight..
  replace_with_na(replace = list(lfm = c(0.00000))) %>% #for missing lfm
  replace_with_na(replace = list(dry.wt = c(0, " ", "  ", "", "   ", "    "))) #for missing dry weight, make NA (need to have all those weird spaces for some reason..)

#Make missing dry weights NA:
data.with.na$dry.wt[is.nan(data.with.na$dry.wt)]<-NA

#To make any odd values due to lack of ignition 'NA:
data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "fh", "mpa", "prop.new", "dry.wt", "water.wt", "fresh.wt", "ttms")][(data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "fh", "mpa", "prop.new", "dry.wt", "water.wt", "fresh.wt", "ttms")] == 0)] <- NA
data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "gti", "water.wt", "fresh.wt", "ttms", "lfm")][(data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "gti", "water.wt", "fresh.wt", "ttms", "lfm")] < 0)] <- NA
data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "gti", "ttms")][(data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "gti", "ttms")] > 1000)] <- NA

raw.data.allnasout <- data.with.na %>%
  na.omit() #REALLY reduces sample size....

#colSums(is.na(data.with.na))

data.with.na <- data.with.na %>%
  mutate(lfm.outliers.out = lfm) ##make column to take out outliers from lfm, while keeping column with original lfms too

```

First, to visualize impact of outliers with outlierKD function (slightly changed here) 
"To detect the outliers I use the command boxplot.stats()$out which use the Tukeyâ€™s method to identify the outliers ranged above and below the 1.5*IQR." (https://www.r-bloggers.com/2016/04/identify-describe-plot-and-remove-the-outliers-from-the-dataset/)

```{r}
#source("http://goo.gl/UUyEzD") #outlier KD (original function)

#The following function is derived from outlierKD (from above)
outlierKD2 <- function(dt, var) {
  var_name <- eval(substitute(var),eval(dt))
  tot <- sum(!is.na(var_name))
  na1 <- sum(is.na(var_name))
  m1 <- mean(var_name, na.rm = T)
  par(mfrow=c(2, 2), oma=c(0,0,3,0))
  boxplot(var_name, main="With outliers")
  hist(var_name, main="With outliers", xlab=NA, ylab=NA)
  outlier <- boxplot.stats(var_name)$out
  mo <- mean(outlier)
  var_name <- ifelse(var_name %in% outlier, NA, var_name)
  boxplot(var_name, main="Without outliers")
  hist(var_name, main="Without outliers", xlab=NA, ylab=NA)
  title("Outlier Check", outer=TRUE)
  na2 <- sum(is.na(var_name))
  message("Outliers identified: ", na2 - na1, " from ", tot, " observations")
  message("Proportion (%) of outliers: ", (na2 - na1) / tot*100)
  message("Mean of the outliers: ", mo)
  m2 <- mean(var_name, na.rm = T)
  message("Mean without removing outliers: ", m1)
  message("Mean if we remove outliers: ", m2)
    dt[as.character(substitute(var))] <- invisible(var_name)
    assign(as.character(as.list(match.call())$dt), dt, envir = .GlobalEnv)
    message("Outliers successfully removed", "\n")
    return(invisible(dt))
}

outlierKD2(data.with.na, lfm.outliers.out) #check for outliers and remove (happens in outliers.out column, lfm column still contains outliers)

data.with.na <- data.with.na %>%
  mutate(lfm.NAs.imputed = lfm.outliers.out) %>%
  impute_rlm(lfm.NAs.imputed ~ mpa) 
```
#Impute missing LFMs based on spp and Mpa: 

For impute_lm and simputation package info, see: http://finzi.psych.upenn.edu/R/library/simputation/html/impute_lm.html

```{r}
#impute:
data.with.na <- data.with.na %>%
  mutate(lfm.NAs.imputed = lfm.outliers.out) %>%
  impute_rlm(lfm.NAs.imputed ~ mpa + spp) #use simputation package to impute missing lfms based on Mpa and spp. 

#Visualize:
as_shadow(data.with.na)
aq_shadow <- bind_shadow(data.with.na)
aq_nab <- nabular(data.with.na)
all.equal(aq_shadow, aq_nab)
#glimpse(aq_nab)

data.with.na %>%
  bind_shadow() %>%
  ggplot(aes(x = mpa, fill = lfm.outliers.out_NA)) +
  geom_histogram()

#imputed missing lfm values (NOTE: we already did this above, but this is just to see what that might look like):
aq_shadow %>%
  impute_lm(lfm.outliers.out ~ mpa + spp) %>%
  ggplot(aes(x = mpa,
             y = lfm.outliers.out, 
             colour = lfm.outliers.out_NA,shape = spp)) + 
  geom_point()
#head(aq_shadow)
```

Now to add some columns to the dataframe (bins of LFM, year.month column to separate trials, rate of spread) and manipulate some variables:
```{r}
data <- data.with.na  %>%
  #mutate(data.with.na, flam.index = 1.6*((449+tti)/(12.5+tti))*exp(fh/(fh+58))) %>% #using max tti and max fh, becomes a scale of least (1) to most (20) flammable (NOTE: had many NA's due to missing values in tti or FH; worth looking into?); ALSO: Need to do this later so we can do it by species; doesn't make sense to do as a group
  unite(year.month, c("year", "month"), remove = FALSE) %>% #group for month and year
  group_by(gr = cut(lfm.NAs.imputed, breaks= seq(0, 400, by = 10))) %>% #create 10 LFM segments, indicate these in new column called "gr"
  ungroup() %>% #ungroup - this will stop issues in the future (we can always regroup again)
  unite(model.spp.gr, c("year", "month", "model", "spp", "gr"), remove = FALSE) %>% #create column for each group as above, and add lfm segment count
  group_by(model.spp.gr) %>% #create groups based on trial, model, species, and lfm segment
  add_tally %>% #column with n for each of these groups
  unite(model.spp.gr.sample, c("year", "month", "model", "spp", "gr", "sample"), remove = FALSE) %>%
  filter(ignition != "2") %>% #we don't want to include any manual ignitions (coded "2"), so remove those
  mutate(ignition = as.integer(ignition)) %>%
  dplyr::group_by(model.spp.gr) %>% #group by year, model, spp, group column
  dplyr::mutate(total = sum(ignition)) %>%
  mutate(prop.ignite = paste0(round(100 * total/n))) %>% #for each group, divide total ignitions ("total" column) by total number burn (n column) attempts as a   percentage
  ungroup() %>% #ungroup so r doesnt get confused
  mutate(fd = as.numeric(fd)) %>% 
  mutate(ros = 10/fd) %>%#create Rate of Spread column (only relevant for HP metrics, but we'll do it for all and just ignore that column when we do EPI analysis):
  mutate(prop.ignite = as.numeric(prop.ignite))
#data$prop.ignite <- as.numeric(data$prop.ignite) #Since, otherwise, it would be a character vector
#str(data)
range(data$prop.ignite)
#str(data)
```

# Now that we have our data how we want it, let's start to deal with outliers and visualize NA values:


Add column labeled "hydration" with break at 80% LFM, and make bins of varying lfm sizes:
 
```{r}
#str(data)
#impute lfm based on relationship with Mpa, grouping by species:
data <- data %>%
  group_by(spp) %>%
#then create bins for LFM, in case we want to compare via bins
  mutate(hydration = cut(lfm.NAs.imputed, breaks = c(0, 80, 400), labels = c("dry", "hydrated"))) %>% 
  ungroup() %>%
  group_by(bins5lfm= cut(lfm.NAs.imputed, breaks= seq(0, 400, by = 5))) %>% #create 10 LFM segments, indicate these in new column called "bins5lfm"
  ungroup() %>% #ungroup - this will stop issues in the future (we can always regroup again)
  group_by(bins10lfm= cut(lfm.NAs.imputed, breaks= seq(0, 400, by = 10))) %>% #create 10 LFM segments, indicate these in new column called "bins10lfm"
  ungroup() %>% #ungroup - this will stop issues in the future (we can always regroup again)
  group_by(bins20lfm = cut(lfm.NAs.imputed, breaks= seq(0, 400, by = 20))) %>% #create 20 LFM segments, indicate these in new column called "bins20lfm"
  ungroup() %>% 
  group_by(bins40lfm = cut(lfm.NAs.imputed, breaks= seq(0, 400, by = 40))) %>% #create 40 LFM segments, indicate these in new column called "bins40lfm"
  ungroup() 
```

#Visualize missing weights and temps:

```{r}
vis_miss(data)
gg_miss_var(data, facet = model)

ggplot(data, 
       aes(x = lfm.NAs.imputed, 
           y = dry.wt)) + 
  geom_miss_point() +
  facet_wrap(~model)

ggplot(data, 
       aes(x = lfm.NAs.imputed, 
           y = fresh.wt)) + 
  geom_miss_point() +
  facet_wrap(~model)

ggplot(data, 
       aes(x = lfm.NAs.imputed, 
           y = water.wt)) + 
  geom_miss_point() +
  facet_wrap(~model)

ggplot(data, 
       aes(x = lfm.NAs.imputed, 
           y = sample.wt)) + 
  geom_miss_point() +
  facet_wrap(~model)

ggplot(data, 
       aes(x = lfm.NAs.imputed, 
           y = start.temp)) + 
  geom_miss_point() +
  facet_wrap(~model)

as_shadow(data)
aq_shadow <- bind_shadow(data)
aq_nab <- nabular(data)
all.equal(aq_shadow, aq_nab)
#glimpse(aq_nab)
```

Make dry weight columns, etc. for PV comparison: 

(EDIT: PV Sat.weight stuff needs to happen in excel due to need for extrapolation..this is still interesting though)

For impute_lm and simputation package info, see: http://finzi.psych.upenn.edu/R/library/simputation/html/impute_lm.html

```{r include=TRUE}
#impute missing weights:
data <- data %>%
  unite(individual, c("year", "month", "spp", "sample"), remove = FALSE) %>% #create 'individual' column
  dplyr::group_by(model.spp.gr) %>%
  impute_median_at(c("dry.wt", "fresh.wt", "water.wt", "bottle.wt", "sample.wt")) %>%
  #impute_lm(fresh.wt ~ lfm.NAs.imputed + spp) %>%
  #impute_lm(water.wt ~ lfm.NAs.imputed + spp) %>%
  #impute_lm(bottle.wt ~ lfm.NAs.imputed + spp) %>%
  #impute_lm(sample.wt ~ lfm.NAs.imputed) %>%
  #ungroup() %>%
  mutate(temp.change = temp.max - start.temp)

colSums(is.na(data))
  
#calculate metrics for weight values (read . as "per", i.e. gdw.gfw is "gram dry weight per gram fresh weight"):
data <- data %>%
  dplyr::mutate(gdw.gfw = dry.wt/fresh.wt) %>%
  dplyr:::mutate(gww.gdw = lfm.NAs.imputed/100) %>%
  dplyr::mutate(gdw.gww = (dry.wt - bottle.wt)/water.wt) %>%
  dplyr::mutate(dw.flam.sample = sample.wt * gdw.gfw)

#deal with weight values from the above (should actually not be needed):
data <- data %>%
  replace_with_na(replace = list(dw.flam.sample = c(0, " ", "  ", "", "   ", "    "))) %>%
  replace_with_na(replace = list(dw.flam.sample = c(0))) %>% #when dw flam is zero (i.e. missing sample weight or missing lfm)
  #replace_with_na_at(.vars = c("dw.flam.sample"), condition = ~.x < 0) %>%
  dplyr::group_by(model.spp.gr) %>%
  impute_lm(dw.flam.sample ~ lfm.NAs.imputed)  %>%
  dplyr::mutate(ww.flam.sample = sample.wt - dw.flam.sample) %>%
  dplyr::group_by(model.spp.gr) %>%
  dplyr::group_by(individual) %>% 
  dplyr::mutate(gww.gdw.saturated = max((gww.gdw), na.rm = TRUE)) %>%
  dplyr::mutate(gdw.gww.saturated = min((gdw.gww), na.rm = TRUE)) %>%
  mutate(RWC = (gww.gdw/gww.gdw.saturated)*100) %>%
  mutate(RWD = 100 - RWC) %>%
  mutate(max.mpa.sample = max((mpa), na.rm = TRUE)) %>%
  select(order(colnames(.))) #make columns in alphabetical order

rwc.data <- data %>%
  select(individual, lfm.NAs.imputed, RWC, max.mpa.sample, mpa, gww.gdw, gww.gdw.saturated, spp)
#str(data)

rwc.lfm.plot <- rwc.data %>%
  ggplot(aes(x = lfm.NAs.imputed, y = RWC, color = spp)) +
  geom_point()
rwc.lfm.plot
```

Changing some character vectors into numeric vectors:
```{r}
data$gti <- as.numeric(as.character(data$gti))
data$gd <- as.numeric(data$gd)
data$pfg <- as.numeric(data$pfg)
data$ttfg <- as.numeric(data$ttfg)
data$tti <- as.numeric(data$tti)
data$ttms <- as.numeric(data$ttms)
summary(data)
#not sure why these were characters... ?
```


# PV curve analysis stuff
(Make a dataset for use with R PV code)

```{r}
#data$max.mpa.gww.gdw <- data %>%
 # group_by(individual) %>%
  #mutate(max.mpa.gww.gdw = mpa(which.max(gww.gdw)))
  #data$mpa[which.max(t(data$gww.gdw))]

pv.curve.local.all <- data %>%
  filter(model == "HP") %>%
  select("sample", "fresh.wt", "dry.wt", "water.wt", "individual", "mpa", "spp", "year.month", "gww.gdw.saturated", "RWC", "RWD", "gww.gdw", "gdw.gfw", "lfm.outliers.out", "lfm.NAs.imputed") %>% #Setting up a new dataframe to use with PV curve function later down the line - EDIT: make sure these are the right columns, need sample, fresh.wt, dry.wt, groupings, etc.
  mutate(sample = sample * 10)  %>% 
  mutate(sample = as.integer(sample)) %>%
  mutate(LFM = lfm.NAs.imputed) %>%
  #mutate(fresh.weight = fresh.wt) %>%
 # mutate(dry.weight = dry.wt) %>%
  arrange(individual, desc(mpa)) #PV analysis requires that Mpa be in descending order within samples.
#Above dataframe has sample, mpa, rwc, fresh wt, dry wt
  

write.csv(pv.curve.local.all, here("processed-data/pv.curve.local.all.csv"))
```

#Look at distributions so we can think about how to deal with NAs:

Information on this: 
https://www.analyticsvidhya.com/blog/2016/03/tutorial-powerful-packages-imputing-missing-values/
https://www.freecodecamp.org/news/the-penalty-of-missing-values-in-data-science-91b756f95a32/ 

Also see:
Nakagawa, S., & Freckleton, R. P. (2011). Model averaging, missing data and multiple imputation: A case study for behavioural ecology. Behavioral Ecology and Sociobiology, 65(1), 103â€“116. https://doi.org/10.1007/s00265-010-1044-7

..we could try multiple imputation method? (Amelia package, or MICE)

This is what I opted for, due to ease of use:
https://www.markvanderloo.eu/yaRb/2016/09/13/announcing-the-simputation-package-make-imputation-simple/

Median is most appropriate if data is slightly skewed.

```{r, message=FALSE, warnings= FALSE}
#str(data)
ignite.only.epi <- data %>%
  filter(ignition == "1") %>%
  filter(model == "EPI") %>% 
  mutate(gti = as.numeric(gti)) 

dist.epi <- ignite.only.epi %>%
  group_by(model.spp.gr) %>% #this makes us take the median of based on the species, the model, and the lfm bins (of 10 lfm) the missing value is in. Preserves species differences, and lfm impact.
  ungroup() %>% 
  impute_median_at(c("ttfg", "gd", "gti", "fd", "pfg","temp.max", "start.temp", "ros", "ignition.temp", "temp.change", "ttms", "fh")) %>%
  #impute_lm(fh ~ spp + lfm.NAs.imputed + temp.max)  %>%
  select(fd, fh, gd, gti, pfg, prop.ignite, ros, temp.max, ttfg, tti)

multi.hist(dist.epi[,sapply(dist.epi, is.numeric)])
```
#ERROR: Ran into an error here, but added line of code ungroup() on line 275 and that fixed it... Not quite sure the graphs make a whole lot of sense though? Specifically the tti, gd, gti, ffg, ttfg graphs look wrong.


To clean up the dataframe a bit and to subset the data a few ways:
```{r}
ignite.only.epi <- ignite.only.epi %>%
  group_by(spp) %>% #this makes us take the median of based on the species, the model, and the lfm bins (of 10 lfm) the missing value is in. Preserves species differences, and lfm impact. 
  impute_median_at(c("ttfg", "gd", "gti", "fd", "pfg","temp.max", "start.temp", "ros", "ignition.temp", "tti", "fh")) %>%
  #impute_lm(fh ~ spp + lfm.NAs.imputed + temp.max) %>%
  #select(-ttms, -prop.new) %>%
  ungroup()
colSums(is.na(ignite.only.epi)) #should not be any NAs in the flammability metrics
```


```{r}
ignite.only.hp <- data %>%
  filter(ignition == "1") %>%
  filter(model == "HP") %>% 
  dplyr::mutate(gti = replace(gti, gti == "0", "0.5")) %>% #replace when gti is zero to .5 seconds, so we can take the log later
  mutate(gti = as.numeric(gti)) %>%
  mutate(gti = as.numeric(gd))

dist.hp <- ignite.only.epi %>%
  select(fd, fh, gd, gti, pfg, ros, temp.max, ttfg, tti, prop.ignite, temp.change, individual)

multi.hist(dist.hp[,sapply(dist.hp, is.numeric)])
```

```{r, warning=FALSE}
ignite.only.hp <- ignite.only.hp %>%
  group_by(model.spp.gr) %>% #this makes us take the median of based on the species, the model, and the lfm bins (of 10 lfm) the missing value is in. Preserves species differences, and lfm impact. 
  impute_median_at(c("ttfg", "gd", "gti", "fd", "pfg","temp.max", "start.temp", "ros", "ignition.temp", "ttms", "temp.change", "tti", "fh")) %>%
  #impute_lm(fh ~ spp + lfm.NAs.imputed + temp.max) %>%
  #select(-ttms, -prop.new) %>%
  ungroup()

colSums(is.na(ignite.only.hp))
```

Combine into master dataset: 
```{r}
ignite.only.epi
ignite.only.hp
ignite.only.all <- rbind(ignite.only.epi, ignite.only.hp)
str(ignite.only.all)
``` 

Look at Flam characteristics to see if they make sense:

```{r}
range(ignite.only.epi$gti)
range(ignite.only.epi$tti)
range(ignite.only.epi$fh)
range(ignite.only.epi$gd) #some very high values here, but they seem to be accurate?
range(ignite.only.epi$pfg) 
range(ignite.only.epi$ttfg)

#source("http://goo.gl/UUyEzD") #outlier KD (original function)
#outlierKD(epi.flam.only, gti)

range(ignite.only.hp$gti)
range(ignite.only.hp$tti)
range(ignite.only.hp$fh)
range(ignite.only.hp$gd)
range(ignite.only.hp$pfg)
range(ignite.only.hp$ttfg)
range(ignite.only.hp$ros)
```

#EPI only: 

Here we are normalizing by the dry weight of the flammability sample, which was calculated by multiplying the weight of the burned sample by the ratio of dry weight to fresh weight in the samples used for lfm measurements. (Assumptions here: that the ratio of water to dry weight in burned and lfm samples was the same)

```{r}
distributions.lfm <- ignite.only.epi %>%
  ggplot() +
  geom_density(aes(x = sample.wt, color = spp))
distributions.lfm  

#colSums(is.na(ignite.only.epi))
#str(ignite.only.epi)
ignite.only.epi <- ignite.only.epi %>%  #Dealing with only EPI trials that ignited (can change later)
  dplyr::mutate(mean.wt = mean(sample.wt, na.rm = TRUE)) %>% #take the mean of all sample weights for each model
  ungroup() %>% 
  mutate_if(is.integer, as.numeric)

#range(ignite.only.epi$dw.flam.sample) #range gets low for some samples (with very low lfm, maybe?)

distributions.dw <- ignite.only.epi %>%
  ggplot() +
  geom_density(aes(x = dw.flam.sample, color = spp))
distributions.dw 

distributions.lfm <- ignite.only.epi %>%
  ggplot() +
  geom_density(aes(x = lfm, color = spp))
distributions.lfm 

ignite.only.epi <- ignite.only.epi %>%
  mutate("dry.norm.fh" = fh/dw.flam.sample) %>% #create new columns, etc.
  mutate("dry.norm.gd" = gd/dw.flam.sample) %>% #
  mutate("dry.norm.fd" = fd/dw.flam.sample) %>%
  mutate("dry.norm.pfg" = pfg/dw.flam.sample) %>% #
  mutate("dry.norm.ttfg" = ttfg/dw.flam.sample) %>% #
  mutate("dry.norm.tti" = tti/dw.flam.sample) %>% #
  mutate("dry.norm.gti" = gti/dw.flam.sample) 

colSums(is.na(ignite.only.epi))
#str(ignite.only.epi)
```

```{r, warnings = FALSE}
distributions <- ignite.only.epi %>%
  select(spp, dry.norm.fh, dry.norm.gd, dry.norm.fd, dry.norm.pfg, dry.norm.gti, dry.norm.ttfg, dry.norm.tti) %>%
  gather(-spp, key = "var", value = "value") %>%
  ggplot() +
  geom_density(aes(x = value, color = spp)) +
  facet_wrap(~ var, scales = "free")
distributions +
  ggtitle("Epiradiator")
```

#USE THIS FOR PCA:

Mirroring Max's PCA dataset (Mac_PCA_DATE.Rmd)

```{r}
epi.ignite.only.Max <- ignite.only.epi %>%
  mutate(mpa = mpa * -1) %>%
  mutate(gti = replace(dry.norm.gti, dry.norm.gti == "0", "0.5")) %>%
  #arrange() %>%
  #select (individual, hydration, spp, sample, model, year.month, mpa, lfm.outliers.out, lfm.NAs.imputed, dw.flam.sample, ww.flam.sample, sample.wt, ttfg, gd, gti, tti, fh, pfg, fd, temp.max, prop.ignite, dry.norm.fh, dry.norm.gd, dry.norm.fd, dry.norm.pfg, dry.norm.gti, dry.norm.ttfg, dry.norm.tti, site,ttms, temp.change)  %>%
 # arrange(individual, hydration, spp, sample, model, year.month, mpa, lfm.outliers.out, lfm.NAs.imputed, sample.wt, dw.flam.sample, ww.flam.sample, ttfg, gd, gti, tti, fh, pfg, fd, temp.max, prop.ignite, dry.norm.fh, dry.norm.gd, dry.norm.fd, dry.norm.pfg, dry.norm.gti, dry.norm.ttfg, dry.norm.tti, site,ttms, temp.change) %>%
  relocate("hydration")
colSums(is.na(epi.ignite.only.Max))

str(epi.ignite.only.Max) 

write.csv(x = epi.ignite.only.Max, here("processed-data/epi.ignite.only.seki.csv"), row.names = F)
```

# Normalizing Data - HP only: 

Here we are normalizing by the dry weight of the flammability sample, which was calculated by multiplying the weight of the burned sample by the ratio of dry weight to fresh weight in the samples used for lfm measurements. (Assumptions here: that the ratio of water to dry weight in burned and lfm samples was the same)

```{r}
#colSums(is.na(ignite.only.hp))
#str(ignite.only.hp)
ignite.only.hp <- ignite.only.hp %>%  #Dealing with only EPI trials that ignited (can change later)
  dplyr::mutate(mean.wt = mean(sample.wt, na.rm = TRUE)) %>% #take the mean of all sample weights for each model
  ungroup() %>% 
  mutate_if(is.integer, as.numeric) 

ignite.only.hp$gti <- as.numeric(as.character(ignite.only.hp$gti)) #not sure why this became a character...
#str(ignite.only.hp)

#range(ignite.only.hp$dw.flam.sample) #range gets low for some samples (with very low lfm, maybe?)

distributions.dw <- ignite.only.hp %>%
  ggplot() +
  geom_density(aes(x = dw.flam.sample, color = spp))
distributions.dw 

distributions.lfm <- ignite.only.hp %>%
  ggplot() +
  geom_density(aes(x = lfm, color = spp))
distributions.lfm 

ignite.only.hp <- ignite.only.hp %>%
  mutate("dry.norm.fh" = fh/dw.flam.sample) %>% #create new columns, etc.
  mutate("dry.norm.gd" = gd/dw.flam.sample) %>%
  mutate("dry.norm.fd" = fd/dw.flam.sample) %>%
  mutate("dry.norm.pfg" = pfg/dw.flam.sample) %>%
  mutate("dry.norm.ttfg" = ttfg/dw.flam.sample) %>%
  mutate("dry.norm.tti" = tti/dw.flam.sample) %>% 
  mutate("dry.norm.gti" = gti/dw.flam.sample) %>%
  mutate("temp.change" = temp.max - start.temp) 

colSums(is.na(ignite.only.hp))
#str(ignite.only.hp)
```

```{r}
distributions <- ignite.only.hp %>%
  select(spp, dry.norm.fh, dry.norm.gd, dry.norm.fd, dry.norm.pfg, dry.norm.gti, dry.norm.ttfg, dry.norm.tti) %>%
  gather(-spp, key = "var", value = "value") %>%
  ggplot() +
  geom_density(aes(x = value, color = spp)) +
  facet_wrap(~ var, scales = "free")
distributions +
  ggtitle("Epiradiator")
```

#USE THIS FOR PCA:

Mirroring Max's PCA dataset (Mac_PCA_DATE.Rmd)

```{r}
hp.ignite.only.pca <- ignite.only.hp %>%
  mutate(mpa = mpa * -1) %>%
  mutate(gti = replace(dry.norm.gti, dry.norm.gti == "0", "0.5")) %>% 
  #select (individual, hydration, spp, sample, model, year.month, mpa, lfm.outliers.out, lfm.NAs.imputed, dw.flam.sample, ww.flam.sample, sample.wt, ttfg, gd, gti, tti, fh, pfg, fd, temp.max, prop.ignite, dry.norm.fh, dry.norm.gd, dry.norm.fd, dry.norm.pfg, dry.norm.gti, dry.norm.ttfg, dry.norm.tti, ros, site, ttms, temp.change)  %>%
  #arrange(individual, hydration, spp, sample, model, year.month, mpa, lfm.outliers.out, lfm.NAs.imputed, sample.wt, dw.flam.sample, ww.flam.sample, ttfg, gd, gti, tti, fh, pfg, fd, temp.max, prop.ignite, dry.norm.fh, dry.norm.gd, dry.norm.fd, dry.norm.pfg, dry.norm.gti, dry.norm.ttfg, dry.norm.tti, ros, site, ttms, temp.change) %>%
  relocate("hydration")
colSums(is.na(hp.ignite.only.pca))

write.csv(x = hp.ignite.only.pca, here("processed-data/hp.ignite.only.seki.csv"), row.names = F)
```


####
####


