---
title: 'Data Wrangling: Sierra Flam. Curves (SEKI)'
author: "Indra Boving"
date: "2/19/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# First, let's get our data how we want it
To load in necessary packages and dataset:
```{r}
library(simputation)
library(visdat)
library(ggplot2) 
library(gapminder)
library(data.table)
library(purrr) #for visualizing all variables in one big plot
library(naniar) #deal with NAs
library(dplyr)
library(tidyverse)
library(ggpubr)
filter = dplyr::filter #correct filter problem (gets confused with stats::filter)
library(purrr) #for visualizing all variables in one big plot
#install.packages("naniar")
library(psych) #for multi.hist
```

```{r}
getwd()
raw.data <- read.csv("/Users/user/Desktop/github/flammability/scripts/SEKI_flammability.csv")
str(raw.data)
```

Now to make a bunch of NA values with values that don't make sense and/or are supposed to be NA, but R did not recognize them immediately as NA:
```{r}
colSums(is.na(raw.data))

raw.data$dry.wt <- as.numeric(raw.data$dry.wt)
data.with.na <- raw.data %>% 
  replace_with_na(replace = list(temp.max = c(0, 0.0))) %>% #for missing temp maxs, make NA
  replace_with_na(replace = list(ignition.temp = c(0, 0.0))) %>% #for missing temp at ignition, make NA (all 2016 & 2018 trials)
  replace_with_na(replace = list(start.temp = c(0, 0.0))) %>% #for missing starting temp, make na
  replace_with_na(replace = list(sample.wt = c(0, 0.0))) %>% #for sample weight...could do mean here?
  replace_with_na(replace = list(lfm = c(0.00000))) %>% #for missing lfm
  replace_with_na(replace = list(dry.wt = c(0, " ", "  ", "", "   ", "    "))) %>% #for missing dry weight, make NA (need to have all those weird spaces for some reason..)
  replace_with_na(replace = list(fh = c(0))) %>% #when FH is zero (i.e. no burns), make NA
  replace_with_na_at(.vars = c("lfm"),
                     condition = ~.x < 1)

#To make any odd values due to lack of ignition 'NA':
data.with.na$dry.wt[is.nan(data.with.na$dry.wt)]<-NA
data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "fh", "mpa", "prop.new", "dry.wt", "water.wt", "fresh.wt", "ttms")][(data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "fh", "mpa", "prop.new", "dry.wt", "water.wt", "fresh.wt", "ttms")] == 0)] <- NA
data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "gti", "water.wt", "fresh.wt", "ttms")][(data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "gti", "water.wt", "fresh.wt", "ttms")] < 0)] <- NA
data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "gti", "ttms")][(data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "gti", "ttms")] > 1000)] <- NA

raw.data.allnasout <- data.with.na %>%
  na.omit() #REALLY reduces sample size....

#colSums(is.na(data.with.na))
```

Now to add some columns to the dataframe (bins of LFM, year.month column to separate trials, rate of spread) and manipulate some variables:
```{r}
data <- data.with.na  %>%
  #mutate(data.with.na, flam.index = 1.6*((449+tti)/(12.5+tti))*exp(fh/(fh+58))) %>% #using max tti and max fh, becomes a scale of least (1) to most (20) flammable (NOTE: had many NA's due to missing values in tti or FH; worth looking into?); ALSO: Need to do this later so we can do it by species; doesn't make sense to do as a group
  unite(year.month, c("year", "month"), remove = FALSE) %>% #group for month and year
  #dplyr::mutate(precip.2mo = year.month) %>% #new column in which to put precip. amounts for prior 2 months
  # dplyr::mutate(precip.2mo = recode(precip.2mo, "2020_September" = 0.01, "2018_January" = 0.09, "2019_December" = 3.69, "2020_January" = 5.82, "2016_December" = 0.61)) %>%
  # dplyr::mutate(precip.4mo = year.month) %>% #new column in which to put precip. amounts for prior 4 months (need to get this data still)***
  # dplyr::mutate(precip.4mo = recode(precip.4mo, "2020_September" = 0.45, "2018_January" = 0.09, "2019_December" = 3.69, "2020_January" = 7.28, "2016_December" = 1.03)) %>%
   #dplyr::mutate(season = year.month) %>% #new column in which to put category of precip. amounts
   #dplyr::mutate(season = recode(season, "2020_September" = "Dry", "2018_January" = "Dry", "2019_December" = "Wet", "2020_January" = "Wet", "2016_December" = "Dry" )) %>%
  group_by(gr = cut(lfm, breaks= seq(0, 400, by = 10))) %>% #create 10 LFM segments, indicate these in new column called "gr"
  ungroup() %>% #ungroup - this will stop issues in the future (we can always regroup again)
  group_by(year, model, spp, gr) %>% #create groups based on trial, model, species, and lfm segment
  add_tally %>% #column with n for each of these groups
  ungroup() %>% #ungroup so r doesnt get confused
  unite(model.spp.gr, c("year", "month", "model", "spp", "gr"), remove = FALSE) %>% #create column for each group as above, and add lfm segment count
  unite(model.spp.gr.sample, c("year", "month", "model", "spp", "gr", "sample"), remove = FALSE) %>%
  unite(year.month, c("year", "month"), remove = FALSE) %>% #group for month and year
  group_by(model.spp.gr)  #group by year, model, spp, group column
 
data <- data %>%
  filter(ignition != "2") %>%
  mutate(ignition = as.integer(ignition)) %>%
  mutate(total = sum(ignition)) %>%
  mutate(prop.ignite = paste0(round(100 * total/n))) %>% #for each group, divide total ignitions ("total" column) by total number burn (n column) attempts as a   percentage
  ungroup() %>% #ungroup so r doesnt get confused
  mutate(lfm.outliers.out = lfm) %>% ##make column to take out outliers from lfm, while keeping column with original lfms too
  mutate(ros = 10/fd) %>%#create Rate of Spread column (only relevant for HP metrics, but we'll do it for all and just ignore that column when we do EPI analysis):
  mutate(prop.ignite = as.numeric(prop.ignite))
#data$prop.ignite <- as.numeric(data$prop.ignite) #Since, otherwise, it would be a character vector
#str(data)

#str(data)
```

# Now that we have our data how we want it, let's start to deal with outliers and visualize NA values

First, to visualize impact of outliers with outlierKD function (slightly changed here) 
"To detect the outliers I use the command boxplot.stats()$out
which use the Tukeyâ€™s method to identify the outliers ranged above and below the 1.5*IQR." (https://www.r-bloggers.com/2016/04/identify-describe-plot-and-remove-the-outliers-from-the-dataset/)

```{r}
#source("http://goo.gl/UUyEzD") #outlier KD (original function)

#The following function is derived from outlierKD (from above)
outlierKD2 <- function(dt, var) {
  var_name <- eval(substitute(var),eval(dt))
  tot <- sum(!is.na(var_name))
  na1 <- sum(is.na(var_name))
  m1 <- mean(var_name, na.rm = T)
  par(mfrow=c(2, 2), oma=c(0,0,3,0))
  boxplot(var_name, main="With outliers")
  hist(var_name, main="With outliers", xlab=NA, ylab=NA)
  outlier <- boxplot.stats(var_name)$out
  mo <- mean(outlier)
  var_name <- ifelse(var_name %in% outlier, NA, var_name)
  boxplot(var_name, main="Without outliers")
  hist(var_name, main="Without outliers", xlab=NA, ylab=NA)
  title("Outlier Check", outer=TRUE)
  na2 <- sum(is.na(var_name))
  message("Outliers identified: ", na2 - na1, " from ", tot, " observations")
  message("Proportion (%) of outliers: ", (na2 - na1) / tot*100)
  message("Mean of the outliers: ", mo)
  m2 <- mean(var_name, na.rm = T)
  message("Mean without removing outliers: ", m1)
  message("Mean if we remove outliers: ", m2)
    dt[as.character(substitute(var))] <- invisible(var_name)
    assign(as.character(as.list(match.call())$dt), dt, envir = .GlobalEnv)
    message("Outliers successfully removed", "\n")
    return(invisible(dt))
}

outlierKD2(data, lfm.outliers.out) #check for outliers and remove (happens in outliers.out column, lfm column still contains outliers)
```

Impute lfm based on relationship with Mpa, and add column labeled "hydration" with break at 60% LFM:

```{r}
str(data)
#impute lfm based on relationship with Mpa, grouping by species:
data <- data  %>%
  mutate(lfm.NAs.imputed = lfm.outliers.out) %>%
  group_by(spp) %>%
  impute_rlm(lfm.NAs.imputed ~ mpa) %>%
#then create bins for LFM, in case we want to compare via bins
  mutate(hydration = cut(lfm.NAs.imputed, breaks = c(0, 60, 400), labels = c("dry", "hydrated"))) %>% 
  ungroup() %>%
  group_by(bins5lfm= cut(lfm.NAs.imputed, breaks= seq(0, 400, by = 5))) %>% #create 10 LFM segments, indicate these in new column called "bins5lfm"
  ungroup() %>% #ungroup - this will stop issues in the future (we can always regroup again)
  group_by(bins10lfm= cut(lfm.NAs.imputed, breaks= seq(0, 400, by = 10))) %>% #create 10 LFM segments, indicate these in new column called "bins10lfm"
  ungroup() %>% #ungroup - this will stop issues in the future (we can always regroup again)
  group_by(bins20lfm = cut(lfm.NAs.imputed, breaks= seq(0, 400, by = 20))) %>% #create 20 LFM segments, indicate these in new column called "bins20lfm"
  ungroup() %>% 
  group_by(bins40lfm = cut(lfm.NAs.imputed, breaks= seq(0, 400, by = 40))) %>% #create 40 LFM segments, indicate these in new column called "bins40lfm"
  ungroup() 
```

#Make dry weight columns, etc. for PV comparison: (EDIT: PV Sat.weight stuff needs to happen in excel due to need for extrapolation..this is still interesting though!)

```{r include=FALSE}
#impute missing weights:

data <- data %>%
  unite(individual, c("year", "month", "spp", "sample"), remove = FALSE) %>% #create 'individual' column
  dplyr::group_by(model.spp.gr) %>%
  impute_lm(dry.wt ~ lfm.NAs.imputed + spp) %>%
  impute_lm(fresh.wt ~ lfm.NAs.imputed + spp) %>%
  impute_lm(water.wt ~ lfm.NAs.imputed + spp) %>%
  impute_lm(bottle.wt ~ lfm.NAs.imputed + spp) %>%
  impute_lm(sample.wt ~ lfm.NAs.imputed) %>%
  ungroup()
colSums(is.na(data))
  
#calculate metrics for weight values (read . as "per", i.e. gdw.gfw is "gram dry weight per gram fresh weight"):
data <- data %>%
  dplyr::mutate(gdw.gfw = dry.wt/fresh.wt) %>%
  dplyr:::mutate(gww.gdw = lfm.NAs.imputed/100) %>%
  dplyr::mutate(gdw.gww = (dry.wt - bottle.wt)/water.wt) %>%
  dplyr::mutate(dw.flam.sample = sample.wt * gdw.gfw)

#deal with weight values from the above (should actually not be needed):
data <- data %>%
  replace_with_na(replace = list(dw.flam.sample = c(0, " ", "  ", "", "   ", "    "))) %>%
  replace_with_na(replace = list(dw.flam.sample = c(0))) %>% #when dw flam is zero (i.e. missing sample weight or missing lfm)
  #replace_with_na_at(.vars = c("dw.flam.sample"), condition = ~.x < 0) %>%
  dplyr::group_by(model.spp.gr) %>%
  impute_lm(dw.flam.sample ~ lfm.NAs.imputed)  %>%
  dplyr::mutate(ww.flam.sample = sample.wt - dw.flam.sample) 

colSums(is.na(data))

data <- data %>%
  dplyr::group_by(model.spp.gr) %>%
  dplyr::group_by(individual) %>% 
  dplyr::mutate(gww.gdw.saturated = max((gww.gdw), na.rm = TRUE)) %>%
  dplyr::mutate(gdw.gww.saturated = min((gdw.gww), na.rm = TRUE))
range(data$gww.gdw.saturated)
range(data$gdw.gww.saturated)

data <- data %>%
  mutate(RWC = (gww.gdw/gww.gdw.saturated)*100) %>%
  mutate(RWD = 100 - RWC) %>%
  mutate(max.mpa.sample = max((mpa), na.rm = TRUE)) %>%
  #top_n(1, gww.gdw) %>%
  #mutate(max.mpa.gww.gdw = data$mpa [which.max(t(data$gww.gdw, na.rm = T))]) %>%
  select(order(colnames(.))) #make columns in alphabetical order

rwc.data <- data %>%
  select(individual, lfm.NAs.imputed, RWC, max.mpa.sample, mpa, gww.gdw, gww.gdw.saturated, spp)
#str(data)

rwc.lfm.plot <- rwc.data %>%
  ggplot(aes(x = lfm.NAs.imputed, y = RWC, color = spp)) +
  geom_point()
rwc.lfm.plot
```

# PV curve analysis stuff
(Make a dataset for use with R PV code)

```{r}
#data$max.mpa.gww.gdw <- data %>%
 # group_by(individual) %>%
  #mutate(max.mpa.gww.gdw = mpa(which.max(gww.gdw)))
  #data$mpa[which.max(t(data$gww.gdw))]

pv.curve.local.all <- data %>%
  filter(model == "HP") %>%
  select("sample", "fresh.wt", "dry.wt", "water.wt", "individual", "mpa", "spp", "year.month", "gww.gdw.saturated", "RWC", "RWD", "gww.gdw", "gdw.gfw", "lfm.outliers.out") %>% #Setting up a new dataframe to use with PV curve function later down the line - EDIT: make sure these are the right columns, need sample, fresh.wt, dry.wt, groupings, etc.
  mutate(sample = sample * 10)  %>% 
  mutate(sample = as.integer(sample)) %>%
  #mutate(fresh.weight = fresh.wt) %>%
 # mutate(dry.weight = dry.wt) %>%
  arrange(individual, desc(mpa)) #PV analysis requires that Mpa be in descending order within samples.
#Above dataframe has sample, mpa, rwc, fresh wt, dry wt
  

write.csv(pv.curve.local.all, "pv.curve.local.all.csv")
```

Look at distributions so we can think about how to deal with NAs:

```{r, message=FALSE, warnings= FALSE}
#str(data)
ignite.only.epi <- data %>%
  filter(ignition == "1") %>%
  filter(model == "EPI") %>% 
  mutate(gti = as.numeric(gti)) 

dist.epi <- ignite.only.epi %>%
  select(fd, fh, gd, gti, pfg, prop.ignite, ros, temp.max, ttfg, tti)

multi.hist(dist.epi[,sapply(dist.epi, is.numeric)])

```

To clean up the dataframe a bit and to subset the data a few ways:
```{r}
ignite.only.epi <- ignite.only.epi %>%
  group_by(spp) %>% #this makes us take the median of based on the species, the model, and the lfm bins (of 10 lfm) the missing value is in. Preserves species differences, and lfm impact. 
  impute_median_at(c("ttfg", "gd", "gti", "fd", "pfg","temp.max", "start.temp", "ros", "ignition.temp")) %>%
  impute_lm(fh ~ spp + lfm.NAs.imputed + temp.max) %>%
  #select(-ttms, -prop.new) %>%
  ungroup()

colSums(is.na(ignite.only.epi)) #should not be any NAs in the flammability metrics
```


```{r}
ignite.only.hp <- data %>%
  filter(ignition == "1") %>%
  filter(model == "HP") %>% 
  dplyr::mutate(gti = replace(gti, gti == "0", "0.5")) %>% #replace when gti is zero to .5 seconds, so we can take the log later
  mutate(gti = as.numeric(gti))

dist.hp <- ignite.only.epi %>%
  select(fd, fh, gd, gti, pfg, ros, temp.max, ttfg, tti)

multi.hist(dist.hp[,sapply(dist.hp, is.numeric)])
```

```{r}
ignite.only.hp <- ignite.only.hp %>%
  group_by(spp) %>% #this makes us take the median of based on the species, the model, and the lfm bins (of 10 lfm) the missing value is in. Preserves species differences, and lfm impact. 
impute_median_at(.vars = c("fh", "ttfg", "gd", "gti", "fd", "pfg","temp.max", "tti","ros", "ttms", "start.temp", "ttms", "ignition.temp")) %>%
  ungroup()

colSums(is.na(ignite.only.hp))
```

Combine into master dataset: 
```{r}
ignite.only.epi
ignite.only.hp
ignite.only.all <- rbind(ignite.only.epi, ignite.only.hp)
str(ignite.only.all)
``` 

Look at Flam characteristics to see if they make sense:

```{r}
range(ignite.only.epi$gti)
range(ignite.only.epi$tti)
range(ignite.only.epi$fh)
range(ignite.only.epi$gd) #check
range(ignite.only.epi$pfg) #check
range(ignite.only.epi$ttfg)

#source("http://goo.gl/UUyEzD") #outlier KD (original function)
#outlierKD(epi.flam.only, gti)

range(ignite.only.hp$gti)
range(ignite.only.hp$tti)
range(ignite.only.hp$fh)
range(ignite.only.hp$gd)
range(ignite.only.hp$pfg)
range(ignite.only.hp$ttfg)
range(ignite.only.hp$ros)
range(ignite.only.hp$ttms) #check, see if missing
```

#EPI only: 

Here we are normalizing by the dry weight of the flammability sample, which was calculated by multiplying the weight of the burned sample by the ratio of dry weight to fresh weight in the samples used for lfm measurements. (Assumptions here: that the ratio of water to dry weight in burned and lfm samples was the same)

```{r}
distributions.lfm <- ignite.only.epi %>%
  ggplot() +
  geom_density(aes(x = sample.wt, color = spp))
distributions.lfm  

#colSums(is.na(ignite.only.epi))
#str(ignite.only.epi)
ignite.only.epi <- ignite.only.epi %>%  #Dealing with only EPI trials that ignited (can change later)
  dplyr::mutate(mean.wt = mean(sample.wt, na.rm = TRUE)) %>% #take the mean of all sample weights for each model
  ungroup() %>% 
  mutate_if(is.integer, as.numeric) 


ignite.only.epi$gti <- as.numeric(as.character(ignite.only.epi$gti)) #not sure why this became a character...
#str(ignite.only.epi)

#range(ignite.only.epi$dw.flam.sample) #range gets low for some samples (with very low lfm, maybe?)

distributions.dw <- ignite.only.epi %>%
  ggplot() +
  geom_density(aes(x = dw.flam.sample, color = spp))
distributions.dw 

distributions.lfm <- ignite.only.epi %>%
  ggplot() +
  geom_density(aes(x = lfm, color = spp))
distributions.lfm 

ignite.only.epi <- ignite.only.epi %>%
  mutate("dry.norm.fh" = fh/dw.flam.sample) %>% #create new columns, etc.
  mutate("dry.norm.gd" = gd/dw.flam.sample) %>%
  mutate("dry.norm.fd" = fd/dw.flam.sample) %>%
  mutate("dry.norm.pfg" = pfg/dw.flam.sample) %>%
  mutate("dry.norm.ttfg" = ttfg/dw.flam.sample) %>%
  mutate("dry.norm.tti" = tti/dw.flam.sample) %>% 
  mutate("dry.norm.gti" = gti/dw.flam.sample) %>%
  mutate("temp.change" = temp.max - start.temp) 

colSums(is.na(ignite.only.epi))
#str(ignite.only.epi)
```

```{r, warnings = FALSE}
distributions <- ignite.only.epi %>%
  select(spp, dry.norm.fh, dry.norm.gd, dry.norm.fd, dry.norm.pfg, dry.norm.gti, dry.norm.ttfg, dry.norm.tti) %>%
  gather(-spp, key = "var", value = "value") %>%
  ggplot() +
  geom_density(aes(x = value, color = spp)) +
  facet_wrap(~ var, scales = "free")
distributions +
  ggtitle("Epiradiator")
```

#USE THIS FOR PCA:

Mirroring Max's PCA dataset (Mac_PCA_DATE.Rmd)

```{r}
epi.ignite.only.Max <- ignite.only.epi %>%
  mutate(mpa = mpa * -1) %>%
  mutate(gti = replace(dry.norm.gti, dry.norm.gti == "0", "0.5")) %>% 
  select (hydration, spp, sample, model, year.month, mpa, lfm.outliers.out, lfm.NAs.imputed, dw.flam.sample, ww.flam.sample, sample.wt, ttfg, gd, gti, tti, fh, pfg, fd, temp.max, prop.ignite, dry.norm.fh, dry.norm.gd, dry.norm.fd, dry.norm.pfg, dry.norm.gti, dry.norm.ttfg, dry.norm.tti)  %>%
  arrange(hydration, spp, sample, model, year.month, mpa, lfm.outliers.out, lfm.NAs.imputed, sample.wt, dw.flam.sample, ww.flam.sample, ttfg, gd, gti, tti, fh, pfg, fd, temp.max, prop.ignite, dry.norm.fh, dry.norm.gd, dry.norm.fd, dry.norm.pfg, dry.norm.gti, dry.norm.ttfg, dry.norm.tti) %>%
  relocate("hydration")
colSums(is.na(epi.ignite.only.Max))

str(epi.ignite.only.Max) 

write.csv(x = epi.ignite.only.Max, file = "epi.ignite.only.seki.csv", row.names = F)
```



# Normalizing Data - HP only: 

Here we are normalizing by the dry weight of the flammability sample, which was calculated by multiplying the weight of the burned sample by the ratio of dry weight to fresh weight in the samples used for lfm measurements. (Assumptions here: that the ratio of water to dry weight in burned and lfm samples was the same)

```{r}
#colSums(is.na(ignite.only.hp))
#str(ignite.only.hp)
ignite.only.hp <- ignite.only.hp %>%  #Dealing with only EPI trials that ignited (can change later)
  dplyr::mutate(mean.wt = mean(sample.wt, na.rm = TRUE)) %>% #take the mean of all sample weights for each model
  ungroup() %>% 
  mutate_if(is.integer, as.numeric) 

ignite.only.hp$gti <- as.numeric(as.character(ignite.only.hp$gti)) #not sure why this became a character...
#str(ignite.only.hp)

#range(ignite.only.hp$dw.flam.sample) #range gets low for some samples (with very low lfm, maybe?)

distributions.dw <- ignite.only.hp %>%
  ggplot() +
  geom_density(aes(x = dw.flam.sample, color = spp))
distributions.dw 

distributions.lfm <- ignite.only.hp %>%
  ggplot() +
  geom_density(aes(x = lfm, color = spp))
distributions.lfm 

ignite.only.hp <- ignite.only.hp %>%
  mutate("dry.norm.fh" = fh/dw.flam.sample) %>% #create new columns, etc.
  mutate("dry.norm.gd" = gd/dw.flam.sample) %>%
  mutate("dry.norm.fd" = fd/dw.flam.sample) %>%
  mutate("dry.norm.pfg" = pfg/dw.flam.sample) %>%
  mutate("dry.norm.ttfg" = ttfg/dw.flam.sample) %>%
  mutate("dry.norm.tti" = tti/dw.flam.sample) %>% 
  mutate("dry.norm.gti" = gti/dw.flam.sample) %>%
  mutate("temp.change" = temp.max - start.temp) 

colSums(is.na(ignite.only.hp))
#str(ignite.only.hp)
```

```{r}
distributions <- ignite.only.hp %>%
  select(spp, dry.norm.fh, dry.norm.gd, dry.norm.fd, dry.norm.pfg, dry.norm.gti, dry.norm.ttfg, dry.norm.tti) %>%
  gather(-spp, key = "var", value = "value") %>%
  ggplot() +
  geom_density(aes(x = value, color = spp)) +
  facet_wrap(~ var, scales = "free")
distributions +
  ggtitle("Epiradiator")
```

#USE THIS FOR PCA:

Mirroring Max's PCA dataset (Mac_PCA_DATE.Rmd)

```{r}
hp.ignite.only.Max <- ignite.only.hp %>%
  mutate(mpa = mpa * -1) %>%
  mutate(gti = replace(dry.norm.gti, dry.norm.gti == "0", "0.5")) %>% 
  select (hydration, spp, sample, model, year.month, mpa, lfm.outliers.out, lfm.NAs.imputed, dw.flam.sample, ww.flam.sample, sample.wt, ttfg, gd, gti, tti, fh, pfg, fd, temp.max, prop.ignite, dry.norm.fh, dry.norm.gd, dry.norm.fd, dry.norm.pfg, dry.norm.gti, dry.norm.ttfg, dry.norm.tti, ros)  %>%
  arrange(hydration, spp, sample, model, year.month, mpa, lfm.outliers.out, lfm.NAs.imputed, sample.wt, dw.flam.sample, ww.flam.sample, ttfg, gd, gti, tti, fh, pfg, fd, temp.max, prop.ignite, dry.norm.fh, dry.norm.gd, dry.norm.fd, dry.norm.pfg, dry.norm.gti, dry.norm.ttfg, dry.norm.tti, ros) %>%
  relocate("hydration")
colSums(is.na(hp.ignite.only.Max))

str(hp.ignite.only.Max) 

write.csv(x = hp.ignite.only.Max, file = "hp.ignite.only.seki.csv", row.names = F)
```


####
####


#Stuff below useful for visualizing, but not needed for data wrangling more generally:


####
####

Now, to visualize NA values (EPI ONLY):
(NOTE: We did this up above, but code is here to take a look if need be)

```{r}
vis_miss(ignite.only.epi)
gg_miss_var(ignite.only.epi, facet = year.month)

ggplot(ignite.only.epi, 
       aes(x = lfm.outliers.out, 
           y = fh)) + 
  geom_miss_point() +
  facet_wrap(~year.month)

as_shadow(ignite.only.epi)
aq_shadow <- bind_shadow(ignite.only.epi)
aq_nab <- nabular(ignite.only.epi)
all.equal(aq_shadow, aq_nab)
glimpse(aq_nab)

ignite.only.epi %>%
  bind_shadow() %>%
  group_by(lfm.outliers.out_NA) %>%
  summarise_at(.vars = "fh",
               .funs = c("mean", "sd", "var", "min", "max"),
               na.rm = TRUE)

ignite.only.epi %>%
  bind_shadow() %>%
  group_by(lfm.outliers.out_NA) %>%
  summarise_at(.vars = "mpa",
               .funs = c("mean", "sd", "var", "min", "max"),
               na.rm = TRUE)

ggplot(aq_shadow, aes(x = mpa,
      colour = lfm.outliers.out_NA)) + 
  geom_density()

ignite.only.epi%>%
  bind_shadow() %>%
  ggplot(aes(x = mpa,
        fill = lfm.outliers.out_NA)) +
  geom_histogram()


lfm <- ignite.only.epi %>%
  ggplot( 
       aes(x = lfm.outliers.out)) + 
  geom_density() +
  facet_wrap(~year.month)
lfm
```

Impute missing NAs based on Mpa as predictor: (EDIT: moved this up so it would be included in PV data, here so code is available if need be)

```{r echo=FALSE}
#imputed missing lfm values 
aq_shadow %>%
  impute_lm(lfm.outliers.out ~ mpa) %>%
  ggplot(aes(x = mpa,
            y = lfm.outliers.out, 
             colour = lfm.outliers.out_NA)) + 
  geom_point()

head(aq_shadow)

#impute NAs from missing values: 
#ignite.epi.imputed.na <- ignite.only.epi %>%
  #mutate(lfm.NAs.imputed = lfm.outliers.out) %>%
  #impute_rlm(lfm.NAs.imputed ~ mpa) %>%
  #mutate(hydration = cut(lfm.NAs.imputed, breaks = c(0, 60, 150), labels = c("dry", "hydrated"))) %>% 
  #ungroup()
#colSums(is.na(ignite.epi.imputed.na))
#write.csv(clean.ignite.only, "lignite.epi.imputed.na.csv") #remove # if you want to see dataframe with imputed NA values as an excel file
```




# Visualizing Data


Labelling stuff:

```{r eval=FALSE, include=FALSE}
var.labs <- c("Flame Duration", "Flame Height (cm)", "Glow Duration", "Glow to Ignition", "Post-Flame Glow", "% Ignited", "Temp. Change", "Max. Temp.", "Time to First Glow", "Time to Ignition")
names(var.labs) <- c("fd","fh","gd","gti","pfg","prop.ignite","temp.change", "temp.max", "ttfg", "tti") #Changing the names of the variables for the plots

dates.labs <- c("December 2016", "January 2018", "December 2019", "January 2020", "September 2020")
names(dates.labs) <- c("2016_December", "2018_January", "2019_December", "2020_January", "2020_September") #Changing the labels for the dates for the plots

be.var.labs <- c("Dry Wt. of Flam. Sample (g)", "Sample Wt. (g)", "Start Temp. (C)")
names(be.var.labs) <- c("dw.flam.sample", "sample.wt", "start.temp") #Changing the labels for the variables for the LFM vs. Burn Environment plots

dist.var.labs <- c("Flam. Sample DW", "Flame Duration", "Flame Height (cm)", "Glow Duration", "Glow to Ignition", "LFM", "LFM (NAs imputed)", "LFM (no outliers)", "Water Potential", "Post-Flame Glow", "% Ignited", "Sample Weight (g)", "Start Temp.", "Max. Temp.", "Time to First Glow", "Time to Ignition", "Temp. Change")
names(dist.var.labs) <- c("dw.flam.sample","fd","fh","gd","gti","lfm", "lfm.NAs.imputed","lfm.outliers.out","mpa", "pfg","prop.ignite","sample.wt", "start.temp", "temp.max", "ttfg", "tti", "temp.change") #Changing the labels for the variables for the distribution plot
```

LFM vs. Flam. Metrics - EPI, ignite only
```{r eval=FALSE, include=FALSE}
plot1.df <- ignite.epi.imputed.na  %>% #Looking at only the EPI trials that ignited
  filter(start.temp > 260) %>%
  filter(start.temp < 280) %>%
  filter(sample.wt < .7) %>%
  select(lfm.outliers.out, mpa, year.month,
         spp, fh, ttfg, tti, fd, gd, gti, pfg,
         temp.max, prop.ignite, temp.change) %>%
  gather(-lfm.outliers.out, -mpa, -spp, -year.month, key = "var", value = "value")

epi.plot.flam1 <- ggplot(plot1.df, aes(x = lfm.outliers.out, y = value, shape = spp, color = year.month, add = "reg.line")) +
  geom_point(size  = 0.5) +
  geom_smooth(method = "lm", size = 0.5, se = FALSE) +
  facet_wrap(~var, scales = "free", labeller = labeller(var = var.labs)) +
  labs(x = "LFM (outliers out)", y = "Value Listed", title = "LFM vs. Flammability Metrics (Outliers Out)", fill = "Date") +
  scale_color_discrete(name = "Date", labels = c("December 2016", "January 2018", "December 2019", "January 2020", "September 2020")) +
  scale_shape_discrete(name = "Species")

epi.plot.flam1 
```

LFM vs. Flam. Metrics - EPI, ignite only, comparing LFM with and without OutlierKD applied:

```{r eval=FALSE, include=FALSE}
plot1.df <- normalize.ignite.epi %>% #Looking at only the EPI trials that ignited
  filter(start.temp > 260) %>%
  filter(start.temp < 280) %>%
  filter(lfm < 200) %>% #filtering out super high LFMs
  filter(sample.wt < .7) %>%
  select(lfm.outliers.out, lfm, mpa, year.month,
         spp, fh, ttfg, tti, fd, gd, gti, pfg,
         temp.max, prop.ignite, temp.change) %>%
  gather(-lfm.outliers.out, -lfm, -mpa, -spp, -year.month, key = "var", value = "value")

epi.plot.flam0 <- ggplot(plot1.df, aes(x = lfm.outliers.out, y = value, color = spp), position = position_dodge()) +
  geom_col()+
  facet_wrap(~var, scales = "free", labeller = labeller(var = var.labs)) +
  labs(x = "LFM", y = "Value Listed", title = "LFM vs. Flammability Metrics", fill = "Species") +
  scale_color_discrete(name = "Date", labels = c("December 2016", "January 2018", "December 2019", "January 2020", "September 2020")) +
  scale_shape_discrete(name = "Species")

epi.plot.flam0 
```
LFM vs. Flam. Metrics - ADFA only; EPI, ignite only
```{r eval=FALSE, include=FALSE}
plot2.df <- subset(plot1.df, subset = spp == "ADFA") #Using same filtering methods as first plot; subsetting only ADFA burns

epi.plot.flam2 <- ggplot(plot2.df, aes(x = lfm.outliers.out, y = value, color = year.month, add = "reg.line")) +
  geom_point(size  = 0.5) +
  geom_smooth(method = "lm", size = 0.5, se = FALSE) +
  facet_wrap(~var, scales = "free", labeller = labeller(var = var.labs)) +
  labs(x = "LFM (outliers out)", y = "Value Listed", title = "LFM vs. Flammability Metrics (Outliers Out)", subtitle = "ADFA Only", fill = "Date") +
  scale_color_discrete(name = "Date", labels = c("December 2016", "January 2018", "September 2020"))

epi.plot.flam2 
```

LFM vs. Flam. Metrics - CEME only; EPI, ignite only
```{r eval=FALSE, include=FALSE}
plot3.df <- subset(plot1.df, subset = spp == "CEME") #Using same filtering methods as first plot; subsetting only CEME burns

epi.plot.flam3 <- ggplot(plot3.df, aes(x = lfm.outliers.out, y = value, color = year.month, add = "reg.line")) +
  geom_point(size  = 0.5) +
  geom_smooth(method = "lm", size = 0.5, se = FALSE) +
  facet_wrap(~var, scales = "free", labeller = labeller(var = var.labs)) +
  labs(x = "LFM (outliers out)", y = "Value Listed", title = "LFM vs. Flammability Metrics (Outliers Out)", subtitle = "CEME Only", fill = "Date") +
  scale_color_discrete(name = "Date", labels = c("December 2019", "January 2020", "September 2020"))

epi.plot.flam3 #Note: same differences as epi.plot.flam2; fixed date issue
```

LFM vs. Burn Environment
```{r eval=FALSE, include=FALSE}
lfm.be.plot1.df <- normalize.ignite.epi %>%
  filter(lfm < 175) %>%
  filter(start.temp > 260) %>%
  filter(start.temp < 280) %>%
  filter(sample.wt < .7) %>%
 select(lfm.outliers.out, mpa, year.month,
         spp,  sample.wt, start.temp, dw.flam.sample) %>%
  gather(-lfm.outliers.out, -mpa, -spp, -year.month, key = "var", value = "value")

lfm.be.plot1 <- ggplot(lfm.be.plot1.df, aes(x = lfm.outliers.out, y = value, shape = spp, color = year.month, add = "reg.line")) +
  geom_point(size  = 0.5) +
  geom_smooth(method = "lm", size = 0.5, se = FALSE) +
  facet_wrap(~var, scales = "free",  labeller = labeller(var = be.var.labs)) +
  labs(x = "LFM (outliers out)", y = "Value Listed", title = "LFM vs. Burn Environment", fill = "Date") +
  scale_color_discrete(name = "Date", labels = c("December 2016", "January 2018", "December 2019", "January 2020", "September 2020")) +
  scale_shape_discrete(name = "Species")

lfm.be.plot1
```
Flame Height vs. Burn Environment
```{r eval=FALSE, include=FALSE}
fh.be.plot1.df <-  normalize.ignite.epi %>%
  filter(lfm < 175) %>%
  filter(start.temp > 260) %>%
  filter(start.temp < 280) %>%
  filter(sample.wt < .7) %>%  #Using same filters as above plot
  select(fh, mpa, year.month,
         spp,  sample.wt, start.temp, dw.flam.sample) %>% #Only major difference is that we select flame height instead of lfm.outliers.out
  gather(-fh, -mpa, -spp, -year.month, key = "var", value = "value")

fh.be.plot1 <- ggplot(fh.be.plot1.df, aes(x = fh, y = value, shape = spp, color = year.month, add = "reg.line")) +
  geom_point(size  = 0.5) +
  geom_smooth(method = "lm", size = 0.5, se = FALSE) +
  facet_wrap(~var, scales = "free",  labeller = labeller(var = be.var.labs)) +
  labs(x = "Flame Height (cm)", y = "Value Listed", title = "Flame Height vs. Burn Environment", fill = "Date") +
  scale_color_discrete(name = "Date", labels = c("December 2016", "January 2018", "December 2019", "January 2020", "September 2020")) +
  scale_shape_discrete(name = "Species")

fh.be.plot1
```

Checking Distributions
```{r eval=FALSE, include=FALSE}
dist.plot <- ignite.epi.imputed.na %>%
  select(lfm.outliers.out, mpa, year.month, lfm.NAs.imputed,
         spp, fh, ttfg, tti, fd, gd, gti, sample.wt, dw.flam.sample, pfg,
         temp.max, prop.ignite, start.temp, mpa, lfm) %>%
  gather(-spp, -year.month, key = "var", value = "value") %>%
  ggplot() +
  labs(x = "Value Listed", y = "Density", title = "Distributions of Flam. Metrics - EPI Burns") +
  theme_minimal() +
  geom_density(aes(x = value, color = spp)) +
  facet_wrap(~ var, scales = "free", labeller = labeller(var = dist.var.labs)) + #Using labels for distribution plots
  scale_color_discrete(name = "Species")

dist.plot #Note: axes are crowded. How to fix?
```

Log-transformed data distributions
```{r}
log.ignite.epi <- log(ignite.epi.imputed.na[, c("lfm.outliers.out", "lfm.NAs.imputed",
        "fh", "ttfg", "tti", "fd", "gd", "gti", "sample.wt", "dw.flam.sample", "pfg",
        "start.temp","temp.max", "prop.ignite", "lfm")]) #Log-transforming 16 variables of interest
log.ignite.epi$year.month <- ignite.epi.imputed.na$year.month #Adding date
log.ignite.epi$spp <- ignite.epi.imputed.na$spp #Adding species
log.ignite.epi$mpa <- log(ignite.epi.imputed.na$mpa*-1) #Adding log of water potential (must multiply by -1 to take log)

log.dist.plot <- log.ignite.epi %>%
  select(lfm.outliers.out, mpa, year.month, lfm.NAs.imputed,
         spp, fh, ttfg, tti, fd, gd, gti, sample.wt, dw.flam.sample, pfg,
         temp.max, prop.ignite, start.temp, mpa, lfm) %>%
  gather(-spp, -year.month, key = "var", value = "value") %>%
  ggplot() +
  labs(x = "Log of Value Listed", y = "Density", title = "Log Transformation",subtitle = "Distributions of Flam. Metrics - EPI Burns") +
  theme_minimal() +
  geom_density(aes(x = value, color = spp)) +
  facet_wrap(~ var, scales = "free", labeller = labeller(var = dist.var.labs)) + #Using labels for distribution plots
  scale_color_discrete(name = "Species")

log.dist.plot #Note: should we be concerned with negative values?
```

# Working with the Hot Plate Burns

Normalizing Data

```{r}
normalize.ignite.hp <- ignite.only.hp %>%  #Dealing with only EPI trials that ignited (can change later)
  group_by(model) %>%
  mutate(mean.wt = mean(sample.wt, na.rm = TRUE)) %>% #take the mean of all sample weights for each model
  ungroup() %>% #ya know why
  mutate("norm.fh" = fh/mean.wt) %>% #create new columns, etc.
  mutate("norm.gd" = gd/mean.wt) %>%
  mutate("norm.fd" = fd/mean.wt) %>%
  mutate("norm.pfg" = pfg/mean.wt) %>%
  mutate("norm.gti" = gti/mean.wt) %>%
  mutate("norm.ttfg" = ttfg/mean.wt) %>%
  mutate("norm.tti" = tti/mean.wt) %>% 
  mutate("temp.change" = temp.max - start.temp) %>% #column for temp change
  mutate_if(is.integer, as.numeric) #necessary?
```

LFM vs. Flam. Characteristics
```{r}
hp.plot1.df <- normalize.ignite.hp %>% #Looking at only the HP trials that ignited
  #filter(start.temp > 260) %>%
  #filter(start.temp < 280) %>% #Should we filter by start temp?
  select(lfm.outliers.out, mpa, year.month,
         spp, fh, ttfg, tti, fd, gd, gti, pfg,
         temp.max, prop.ignite, temp.change) %>%
  gather(-lfm.outliers.out, -mpa, -spp, -year.month, key = "var", value = "value")

hp.plot.flam1 <- ggplot(hp.plot1.df, aes(x = lfm.outliers.out, y = value, shape = spp, color = year.month, add = "reg.line")) +
  geom_point(size  = 0.5) +
  geom_smooth(method = "lm", size = 0.5, se = FALSE) +
  facet_wrap(~var, scales = "free", labeller = labeller(var = var.labs)) +
  labs(x = "LFM (outliers out)", y = "Value Listed", title = "LFM vs. Flammability Metrics (Outliers Out)", fill = "Date") +
  scale_color_discrete(name = "Date", labels = c("September 2020")) +
  scale_shape_discrete(name = "Species")

hp.plot.flam1 #Note: Did this to match above plots (slightly different from Indra's code)
```

LFM vs. Flam. Metrics (with Normalized metrics included)
```{r}
hp.plot2.df <- normalize.ignite.hp %>% #Looking at only the HP trials that ignited
  #filter(start.temp > 260) %>%
  #filter(start.temp < 280) %>% #Should we filter by start temp?
  select(mpa, spp, fh, ttfg, tti,
         norm.fh, norm.gd, fd, gd, pfg, gti,
         temp.change, prop.ignite, ros, year.month, lfm.outliers.out) %>%
  gather(-lfm.outliers.out, -mpa, -spp, -year.month, key = "var", value = "value")

hp.plot.flam2 <- ggplot(hp.plot2.df, aes(x = lfm.outliers.out, y = value, shape = spp, color = year.month, add = "reg.line")) +
  geom_point(size  = 0.5) +
  geom_smooth(method = "lm", size = 0.5, se = FALSE) +
  facet_wrap(~var, scales = "free") +
  labs(x = "LFM (outliers out)", y = "Value Listed", title = "LFM vs. Flammability Metrics (Outliers Out)", 
       subtitle = "Normalized Metrics Included", fill = "Date") +
  scale_color_discrete(name = "Date", labels = c("September 2020")) +
  scale_shape_discrete(name = "Species")

hp.plot.flam2  #Note: need to change labels
```

```{r}
hp.dist.plot <- normalize.ignite.hp %>%
  select(lfm.outliers.out, mpa, year.month,
         spp, fh, ttfg, tti, fd, gd, gti, sample.wt, pfg,
         temp.max, prop.ignite, start.temp, mpa, lfm.outliers.out, lfm, temp.change) %>%
  gather(-spp, -year.month, key = "var", value = "value") %>%
  ggplot() +
  labs(x = "Value Listed", y = "Density", title = "Distributions of Flam. Metrics - EPI Burns") +
  theme_minimal() +
  geom_density(aes(x = value, color = spp)) +
  facet_wrap(~ var, scales = "free", labeller = labeller(var = dist.var.labs)) + #Using labels for distribution plots
  scale_color_discrete(name = "Species")

hp.dist.plot
```

