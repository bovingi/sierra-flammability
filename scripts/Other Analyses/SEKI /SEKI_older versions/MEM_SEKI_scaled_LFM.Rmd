---
title: "Scaled local data, Mpa and weight models"
date: "3/13/2021"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#lots of extra here, but oh well... 
library(ggplot2)
library(gapminder)
library(data.table)
library(purrr) #for visualizing all variables in one big plot
library(naniar) #for dealing with NAs nicely 
library(dplyr)
library(tidyverse)
library(devtools)
library(ggfortify)
library(ggpubr)
library(lme4)
library(jtools)
library(lmerTest) #for mixed effects models
library(ggeffects)  # install the package first if you haven't already, then load it
library(GGally) #for corr plots
require(kimisc) # has the nlist function to create a named list
require(AICcmodavg) # has the aictab function
library(lme4)
library(psych)
library(simputation) #for imputation and visualizing missings
library(here)
here=here::here
```


```{r cars, message = FALSE}
mem.data.raw <- read_csv(here("processed-data/seki.alldata.04.12.2021.csv"))
str(mem.data.raw)
```

# Sort and scale data:
```{r}
#Parsing out the variables of interest for the mixed effects modelling:
clean.mem.data <- mem.data.raw[,c('PC1', 'PC2', 'PC3', 'PC4', 'spp', 'lfm.NAs.imputed', 'lfm.outliers.out', 'mpa', 'dw.flam.sample', 'individual','sample.wt', 'ww.flam.sample', 'gww.gdw.saturated', 'gdw.gww.saturated', 'start.temp', 'tti', 'fh', 'gd', 'temp.max', 'model', 'site')] 

#To scale, separate predictors and dependants, and scale numererical predictors:
clean.mem.data.noscale <- clean.mem.data[,c('PC1', 'PC2', 'PC3', 'PC4', 'tti', 'fh', 'gd', 'temp.max', 'individual', 'model', 'spp', 'site')] 
  
scaled.mem.data.predictors <- clean.mem.data %>%
    select('lfm.NAs.imputed', 'lfm.outliers.out', 'mpa', 'dw.flam.sample','sample.wt', 'ww.flam.sample', 'gww.gdw.saturated', 'gdw.gww.saturated', 'start.temp') %>%
  select(where(is.numeric)) %>%
    scale(center = TRUE) 

#scale and center by subtracting the column means, and then dividing by the standard deviation of those centered columns

#Attach scaled predictors and dependants back into one dataset:
scaled.mem.data <- cbind(scaled.mem.data.predictors, clean.mem.data.noscale) 
```

#Visualize the different devices: 

```{r}
plot <- ggplot(scaled.mem.data, aes(x = lfm.NAs.imputed, y = tti, color = spp)) + 
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) + 
  facet_wrap(~model, scales = "free")
plot

plot <- ggplot(clean.mem.data, aes(x = lfm.NAs.imputed, y = tti, color = spp)) + 
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) + 
  facet_wrap(~model, scales = "free")
plot
```
Since we don't have a lot of overlap (Epi broke), let's just use our hot plate trials: 

```{r}
scaled.mem.data.hp <- scaled.mem.data %>%
  filter(model == "HP")
```

##START MODEL BUILDING: 

#When chosing random effects: 
1. Should not be continuous
2. Should be independant of response variable and normally distributed
3. Should have >10 levels
4. Should be random (this is procedural; we are good here)

#Our random effects:
indvidual nested in site

#Our fixed effects:
lfm, mpa, weight metric, start temp, spp (OR do separate models for each spp)

##Hot plate only:

```{r}
#check for collinearity: 
collin.check.hp <- scaled.mem.data.hp %>%
  select(mpa, lfm.outliers.out, dw.flam.sample, ww.flam.sample, tti, start.temp, fh, gd, gdw.gww.saturated)
pairs.panels(collin.check.hp) 
```
\newpage

# How to interpret the scaled regressors: 
 
 "Holding everything else constant, on average, a one standard deviation change in one of the regressors is associated with a change in the dependant variable corresponding to the coefficient of that regressor...". 

https://stackoverflow.com/questions/14510277/scale-back-linear-regression-coefficients-in-r-from-scaled-and-centered-data 

"To de-scale or back-transform regression coefficients from a regression done with scaled predictor variable(s) and non-scaled response variable the intercept and slope should be calculated as:

A = As - Bs*Xmean/sdx
B = Bs/sdx"

As = intercept from the scaled regression
Bs = slope from the scaled regression
Xmean = the mean of the scaled predictor variable
sdx = the standard deviation of the predictor variable
 
See also: https://stackoverflow.com/questions/24268031/unscale-and-uncenter-glmer-parameters/24286763#24286763 

 Example: 
 - Every decrease in LFM of 1 SD results in an increase in time to ignition of *coefficient* seconds. 
 (or: Every 1 LFM decrease results in an increase in tti of *coefficient/sd(lfm)* seconds)?
 - CECO ignite 7.37 seconds later than ARPA
 . 
 Intercept:
 - When the plants are at their mean level of hydration (scaled+centered LFM = 0), CECO's time to ignition is 40.835 seconds (ARPA's tti is 33.465 sec) 
 
\newpage

#All SPECIES:
 
```{r}
lfm.maxmod.allspp <- lmer(tti ~ lfm.NAs.imputed + sample.wt + spp + start.temp  + (1|site:individual), data = scaled.mem.data)

summary(lfm.maxmod.allspp)
car::vif(lfm.maxmod.allspp)
```

```{r, include=FALSE}
## backward elimination of non-significant effects:
step_result.allspp <- step(lfm.maxmod.allspp)
## Elimination tables for random- and fixed-effect terms:
step_result.allspp
# Extract the model that step found:
final_model.allspp <- get_model(step_result.allspp)
final_model.allspp
```

```{r}
summary(final_model.allspp)
```

```{r}
plot(final_model.allspp)
```

```{r}
sjPlot::plot_model(final_model.allspp, show.values = TRUE, show.p = TRUE, 
                   title = "Time to Ignition")

table <- sjPlot::tab_model(final_model.allspp, show.re.var = TRUE, show.std = TRUE)
table
```

\newpage

ARPA only: 
 
```{r}
scaled.mem.data.ARPA <- scaled.mem.data %>%
  filter(spp == "ARPA")

lfm.maxmod.ARPA <- lmer(tti ~ lfm.NAs.imputed + sample.wt + start.temp  +  (1|site:individual), data = scaled.mem.data.ARPA)
summary(lfm.maxmod.ARPA)
car::vif(lfm.maxmod.ARPA)
```

```{r}
## backward elimination of non-significant effects:
step_result.ARPA <- step(lfm.maxmod.ARPA)
## Elimination tables for random- and fixed-effect terms:
step_result.ARPA
# Extract the model that step found:
final_model.ARPA <- get_model(step_result.ARPA)
final_model.ARPA
```

```{r}
summary(final_model.ARPA)
```

```{r}
plot(final_model.ARPA)
```

```{r}
sjPlot::plot_model(final_model.ARPA, show.values = TRUE, show.p = TRUE, 
                   title = "Time to Ignition")

sjPlot::tab_model(final_model.ARPA, show.re.var = TRUE)

```

#Use chosen model, but add in 

```{r}
final_model_ARPA2 <- lmer(formula = tti ~ lfm.NAs.imputed + sample.wt + start.temp + (1|site:individual), data = scaled.mem.data.ARPA)

summary(final_model_ARPA2)
AIC(final_model_ARPA2)
AIC(lfm.maxmod.ARPA)
```


\newpage

CADE only: 
 
```{r}
scaled.mem.data.CADE <- scaled.mem.data %>%
  filter(spp == "CADE")

lfm.maxmod.CADE <- lmer(tti ~ lfm.NAs.imputed  + start.temp + (1|site:individual), data = scaled.mem.data.CADE)

AIC(lfm.maxmod.CADE)
summary(lfm.maxmod.CADE)
car::vif(lfm.maxmod.CADE)
```

```{r}
## backward elimination of non-significant effects:
step_result.CADE <- step(lfm.maxmod.CADE)
## Elimination tables for random- and fixed-effect terms:
step_result.CADE
# Extract the model that step found:
final_model.CADE <- get_model(step_result.CADE)
final_model.CADE
```

```{r}
summary(final_model.CADE)
```

```{r}
plot(final_model.CADE)
```

```{r}
sjPlot::plot_model(final_model.CADE, show.values = TRUE, show.p = TRUE, 
                   title = "Time to Ignition")

sjPlot::tab_model(final_model.CADE, show.re.var = TRUE)
```

\newpage

PIJE only: 
 
```{r}
scaled.mem.data.PIJE <- scaled.mem.data %>%
  filter(spp == "PIJE")

lfm.maxmod.PIJE <- lmer(tti ~ lfm.NAs.imputed  + start.temp + (1|site:individual), data = scaled.mem.data.PIJE)

AIC(lfm.maxmod.PIJE)
summary(lfm.maxmod.PIJE)
car::vif(lfm.maxmod.PIJE)
```

```{r}
## backward elimination of non-significant effects:
step_result.PIJE <- step(lfm.maxmod.PIJE)
## Elimination tables for random- and fixed-effect terms:
step_result.PIJE
# Extract the model that step found:
final_model.PIJE <- get_model(step_result.PIJE)
final_model.PIJE
```

```{r}
summary(final_model.PIJE)
```

```{r}
plot(final_model.PIJE)
```

```{r}
sjPlot::plot_model(final_model.PIJE, show.values = TRUE, show.p = TRUE, 
                   title = "Time to Ignition")

sjPlot::tab_model(final_model.PIJE, show.re.var = TRUE)
```

\newpage

QUKE only: 
 
```{r}
scaled.mem.data.QUKE <- scaled.mem.data %>%
  filter(spp == "QUKE")

lfm.maxmod.QUKE <- lmer(tti ~ lfm.NAs.imputed  + start.temp + (1|site:individual), data = scaled.mem.data.QUKE)

AIC(lfm.maxmod.QUKE)
summary(lfm.maxmod.QUKE)
car::vif(lfm.maxmod.QUKE)
```

```{r}
## backward elimination of non-significant effects:
step_result.QUKE <- step(lfm.maxmod.QUKE)
## Elimination tables for random- and fixed-effect terms:
step_result.QUKE
# Extract the model that step found:
final_model.QUKE <- get_model(step_result.QUKE)
final_model.QUKE
```

```{r}
summary(final_model.QUKE)
```

```{r}
plot(final_model.QUKE)
```

```{r}
sjPlot::plot_model(final_model.QUKE, show.values = TRUE, show.p = TRUE, 
                   title = "Time to Ignition")

sjPlot::tab_model(final_model.QUKE, show.re.var = TRUE)
```

\newpage

ABCO only: 
 
```{r}
scaled.mem.data.ABCO <- scaled.mem.data %>%
  filter(spp == "ABCO")

lfm.maxmod.ABCO <- lmer(tti ~ lfm.NAs.imputed  + start.temp + (1|site:individual), data = scaled.mem.data.ABCO)

AIC(lfm.maxmod.ABCO)
summary(lfm.maxmod.ABCO)
car::vif(lfm.maxmod.ABCO)
```

```{r}
## backward elimination of non-significant effects:
step_result.ABCO <- step(lfm.maxmod.ABCO)
## Elimination tables for random- and fixed-effect terms:
step_result.ABCO
# Extract the model that step found:
final_model.ABCO <- get_model(step_result.ABCO)
final_model.ABCO
```

```{r}
summary(final_model.ABCO)
```

```{r}
plot(final_model.ABCO)
```

```{r}
sjPlot::plot_model(final_model.ABCO, show.values = TRUE, show.p = TRUE, 
                   title = "Time to Ignition")

sjPlot::tab_model(final_model.ABCO, show.re.var = TRUE)
```

#All together:

Helpful for use with plots and tables: 

https://strengejacke.github.io/sjPlot/articles/tab_mixed.html


```{r}
# load required packages
library(sjPlot) # table functions
library(sjmisc) # sample data
library(lme4) # fitting models
```

Final models: 
```{r}
prettytable.trees <- tab_model(final_model.ARPA, final_model.ABCO, final_model.CADE, final_model.QUKE,final_model.PIJE,  dv.labels = c("ARPA", "ABCO", "CADE", "QUKE", "PIJE"), show.std = TRUE)
prettytable.trees
```

Maximal Models: 

```{r}
prettytable.trees.max <- tab_model(lfm.maxmod.ABCO, lfm.maxmod.ARPA, lfm.maxmod.CADE, lfm.maxmod.QUKE,lfm.maxmod.PIJE,  dv.labels = c("ABCO", "ARPA", "CADE", "QUKE", "PIJE"), show.std = TRUE)
prettytable.trees.max
```
